# DarkMatter Architecture Refactor Plan

## Goal
Break the 6,907-line `server.py` monolith into a clean package with separated concerns, abstract interfaces for extensibility, and an acyclic dependency graph.

## Target Structure

```
darkmatter/
├── __init__.py          # Package version, public API
├── config.py            # All constants, env vars, feature flags (~100 lines)
├── models.py            # Data models: Connection, AgentState, QueuedMessage, etc. (~200 lines)
├── identity.py          # Ed25519 passport, sign/verify, input validation, SSRF (~200 lines)
├── state.py             # State persistence: save/load JSON, replay protection (~250 lines)
├── router.py            # RouterAction/Decision/Rule, rule matching, router chain (~150 lines)
├── wallet/
│   ├── __init__.py      # Abstract WalletProvider interface + registry (~60 lines)
│   ├── solana.py        # Solana: balance, send SOL/SPL, derive keypair (~200 lines)
│   └── gas.py           # Gas economy: match game, elder selection, signals, timeout (~400 lines)
├── network/
│   ├── __init__.py      # _send_to_peer (WebRTC-first, HTTP fallback) (~50 lines)
│   ├── mesh.py          # All /__darkmatter__/* HTTP handlers (~700 lines)
│   ├── webrtc.py        # WebRTC offer/answer, data channel, cleanup (~200 lines)
│   ├── discovery.py     # LAN multicast, localhost scan, anchor registration (~200 lines)
│   └── resilience.py    # Health loop, peer lookup, webhook recovery, NAT/UPnP (~450 lines)
├── mcp/
│   ├── __init__.py      # MCP app setup, session tracking (~50 lines)
│   ├── tools.py         # All 28 MCP tool definitions (~1800 lines)
│   ├── schemas.py       # Pydantic input/output models (~200 lines)
│   └── visibility.py    # Dynamic tool show/hide, status line builder (~200 lines)
├── spawn.py             # SpawnedAgent, spawn/kill/cleanup, prompt building (~250 lines)
├── bootstrap.py         # /bootstrap endpoints, port detection, self-replication (~100 lines)
└── app.py               # create_app(), startup hooks, _run_stdio_with_http, main (~300 lines)
```

**Plus at repo root:**
```
server.py                # Thin wrapper: `from darkmatter.app import main; main()`
```

## Dependency Graph (acyclic)

```
config ← (leaf, no deps)
   ↑
models ← config
   ↑
identity ← config
   ↑
state ← models, identity
   ↑
router ← models
   ↑
wallet/__init__ ← models                    (abstract interface)
wallet/solana ← wallet/__init__, identity   (concrete impl)
wallet/gas ← wallet/__init__, models        (uses network at runtime via callback)
   ↑
network/__init__ ← models, config
network/webrtc ← models, config
network/discovery ← models, config, identity
network/resilience ← models, identity, network/__init__
network/mesh ← models, identity, state, router, wallet, spawn, network/*
   ↑
mcp/schemas ← (leaf, Pydantic models only)
mcp/tools ← models, state, identity, wallet, network, router, mcp/schemas
mcp/visibility ← models, mcp/tools
mcp/__init__ ← mcp/tools, mcp/visibility
   ↑
spawn ← models, config
bootstrap ← config
   ↑
app ← everything (composition root)
```

**Key rule:** No circular imports. Lower layers never import upper layers. Where cross-cutting calls are needed (e.g., gas economy needs to send HTTP), use callbacks or pass functions at init time rather than direct imports.

## Module Details

### `config.py`
All constants currently scattered across lines 94-191. Env var reads, feature flags, port ranges, timeouts. Single source of truth for every tunable.

### `models.py`
Pure data classes, no logic:
- `AgentStatus`, `Connection`, `Impression`, `PendingConnectionRequest`
- `QueuedMessage`, `SentMessage`, `AgentState`
- `GasSignal` (moved from gas, it's a data model)
- `RouterAction`, `RouterDecision`, `RoutingRule`
- `SpawnedAgent`

### `identity.py`
Crypto + validation (they're closely related - both about trust boundaries):
- `generate_keypair()`, `derive_public_key_hex()`
- `load_or_create_passport()`
- `sign_message()`, `verify_message()`
- `validate_url()`, `is_private_ip()`, `validate_webhook_url()`
- `truncate_field()`, `check_rate_limit()`

### `state.py`
- `state_file_path()`, `save_state()`, `load_state_from_file()`
- Replay protection: `check_message_replay()`, seen message tracking
- File locking for atomic writes

### `router.py`
- `rule_matches()`, `rule_router()`, `spawn_router()`, `queue_router()`
- `set_custom_router()`, `get_router_chain()`
- Serialization helpers for routing rules

### `wallet/__init__.py` — Abstract Interface
```python
class WalletProvider(ABC):
    """Abstract wallet provider. Implement for each chain."""
    chain: str

    @abstractmethod
    async def get_balance(self, address: str, mint: str | None = None) -> dict: ...

    @abstractmethod
    async def send(self, private_key, recipient: str, amount: float,
                   token: str | None = None) -> dict: ...

    @abstractmethod
    def derive_address(self, passport_private_key: bytes) -> str: ...

# Registry
_providers: dict[str, WalletProvider] = {}

def register_provider(provider: WalletProvider): ...
def get_provider(chain: str) -> WalletProvider | None: ...
def get_all_providers() -> dict[str, WalletProvider]: ...
```

### `wallet/solana.py` — Concrete Implementation
Implements `WalletProvider` for Solana. All current Solana-specific code:
- `derive_address()` (domain-separated Ed25519 → Solana keypair)
- `get_balance()` (SOL + SPL via RPC)
- `send()` (SOL + SPL transfers, ATA creation)
- `SPL_TOKENS` dict, `resolve_spl_token()`
- Auto-registers on import if `solana`/`solders` available

### `wallet/gas.py` — Gas Economy
- `select_elder()`, `run_match_game()`
- `initiate_gas_from_payment()`, `resolve_gas()`
- `gas_timeout_watchdog()`
- `adjust_trust()`
- Gas signal serialization

### `network/mesh.py` — HTTP Handlers
All `handle_*` functions for `/__darkmatter__/*` routes. This is the largest module (~700 lines) but it's cohesive — every function is an HTTP request handler for the mesh protocol.

### `network/resilience.py`
- `lookup_peer_url()` (anchor + fan-out)
- `webhook_request_with_recovery()`
- `network_health_loop()` (background task)
- `poll_webhook_relay()` (NAT relay)
- `discover_public_url()`, `check_nat_status()`
- `try_upnp_mapping()`, `cleanup_upnp()`

### `network/discovery.py`
- `DiscoveryProtocol` (UDP multicast)
- `probe_port()`, `scan_local_ports()`
- `discovery_loop()` (background task)
- `ensure_entrypoint_running()`
- `register_with_anchors()`

### `mcp/tools.py`
All 28 tool definitions. This stays large (~1800 lines) but it's a flat list of tool handlers — easy to navigate and each tool is self-contained.

### `mcp/schemas.py`
All Pydantic input models (`ConnectionInput`, `SendMessageInput`, etc.). Pulled out of tools.py so the schemas are reusable by tests and other code.

### `mcp/visibility.py`
- `compute_visible_optional()`
- `build_status_line()`
- `update_status_tool()`
- `notify_tools_changed()`
- `initialize_tool_visibility()`

### `spawn.py`
- `can_spawn_agent()`, `spawn_agent()`
- `is_agent_running()`, `kill_agent()`
- `cleanup_finished_agents()`, `cleanup_terminal_files()`
- `build_agent_prompt()`

### `bootstrap.py`
- `handle_bootstrap()`, `handle_bootstrap_source()`
- `check_port_owner()`, `find_free_port()`

### `app.py` — Composition Root
- `init_state()` — wires everything together
- `create_app()` — Starlette app factory, registers routes, starts background tasks
- `run_stdio_with_http()` — dual transport startup
- `main()` — entry point

## Migration Strategy

1. **Create `darkmatter/` package** with `__init__.py`
2. **Bottom-up extraction** — start with leaf modules that have no internal deps:
   - `config.py` → `models.py` → `identity.py` → `state.py`
3. **Extract wallet abstraction** — `wallet/__init__.py` then `wallet/solana.py` then `wallet/gas.py`
4. **Extract network layer** — `network/resilience.py` → `network/discovery.py` → `network/webrtc.py` → `network/mesh.py`
5. **Extract MCP layer** — `mcp/schemas.py` → `mcp/tools.py` → `mcp/visibility.py`
6. **Extract remaining** — `router.py`, `spawn.py`, `bootstrap.py`
7. **Wire up `app.py`** — the composition root that imports everything
8. **Make `server.py` a thin wrapper** — `from darkmatter.app import main; main()`
9. **Run tests** — ensure `test_identity.py`, `test_network.py`, `test_discovery.py` all pass
10. **Update `entrypoint.py`** — adjust imports from `server` → `darkmatter.*`

## What Changes for Users

**Nothing.** `server.py` still works as the entry point. `.mcp.json` still points to `server.py`. The `darkmatter/` package is an internal implementation detail. Bootstrap still serves `server.py` (which now contains a one-liner import).

Wait — bootstrap serves the raw `server.py` source. After refactoring, bootstrapping needs to serve the entire `darkmatter/` package. Options:
- **Option A:** Bootstrap serves a zip/tarball of the package
- **Option B:** Bootstrap still serves a single-file `server.py` generated by concatenating the package (build step)
- **Option C:** Bootstrap points to `git clone` / `pip install` instead

**Recommendation:** Option A — serve a zip. The install.sh script already downloads and extracts. Minimal change to the bootstrap flow.
