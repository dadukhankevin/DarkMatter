{% extends "base.html" %}
{% block title %}WormHole{% endblock %}
{% block content %}

<div class="flex h-[calc(100vh-44px)] relative">

  <!-- ================================================================== -->
  <!-- LEFT PANEL — QR Code + Connect + Discovery + Pending + Connections  -->
  <!-- ================================================================== -->
  <div id="left-panel" class="w-64 bg-dim border-r border-edge flex flex-col shrink-0 overflow-hidden hidden md:flex z-20">

    <!-- QR Code panel -->
    <div id="qr-panel" class="border-b border-edge">
      <button onclick="toggleQR()" class="w-full px-3 py-2 flex items-center justify-between hover:bg-slab/50 transition-colors">
        <div class="flex items-center gap-2">
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><rect x="0.5" y="0.5" width="4" height="4" rx="0.5" stroke="currentColor" stroke-width="0.8" class="text-mesh-cyan"/><rect x="7.5" y="0.5" width="4" height="4" rx="0.5" stroke="currentColor" stroke-width="0.8" class="text-mesh-cyan"/><rect x="0.5" y="7.5" width="4" height="4" rx="0.5" stroke="currentColor" stroke-width="0.8" class="text-mesh-cyan"/><rect x="8" y="8" width="3" height="3" rx="0.5" fill="currentColor" class="text-mesh-cyan" opacity="0.4"/></svg>
          <span class="text-[10px] text-mesh-cyan font-medium uppercase tracking-wider">LAN Access</span>
        </div>
        <svg id="qr-chevron" class="text-muted transition-transform" width="10" height="10" viewBox="0 0 10 10"><path d="M3 4l2 2 2-2" stroke="currentColor" stroke-width="1.2" fill="none"/></svg>
      </button>
      <div id="qr-content" class="px-3 pb-3 hidden">
        <div id="qr-code" class="flex justify-center mb-2"></div>
        <div id="qr-url" class="text-[10px] text-pale text-center break-all select-all"></div>
        <div id="qr-unavailable" class="text-[10px] text-muted text-center italic hidden">LAN not available</div>
      </div>
    </div>

    <!-- Connect form -->
    <div class="px-3 py-2.5 border-b border-edge">
      <form id="connect-form" class="flex gap-1.5">
        <input type="text" name="url" placeholder="http://host:port"
          class="flex-1 bg-slab border border-edge rounded px-2 py-1.5 text-[11px] text-bright placeholder-muted focus:border-solar-500/60 transition-colors min-w-0">
        <button type="submit"
          class="bg-solar-600/80 hover:bg-solar-500 text-ink text-[11px] font-bold px-2.5 py-1.5 rounded transition-colors shrink-0">
          +
        </button>
      </form>
    </div>

    <!-- Discovered agents -->
    <div id="discovered-section" class="border-b border-edge">
      <div class="px-3 py-2 flex items-center justify-between">
        <div class="flex items-center gap-2">
          <div class="w-1.5 h-1.5 rounded-full bg-mesh-blue"></div>
          <span class="text-[10px] text-mesh-blue font-medium uppercase tracking-wider">Discovered</span>
        </div>
        <button onclick="fetch('/api/scan',{method:'POST'}).then(()=>pollServer())"
          class="text-muted hover:text-pale text-[10px] transition-colors">scan</button>
      </div>
      <div id="discovered-list" class="px-3 pb-2 space-y-1">
        <p class="text-[10px] text-muted italic">Scanning...</p>
      </div>
    </div>

    <!-- Pending requests -->
    <div id="pending-section" class="hidden border-b border-edge">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="w-1.5 h-1.5 rounded-full bg-mesh-purple pulse-dot"></div>
        <span class="text-[10px] text-mesh-purple font-medium uppercase tracking-wider">Pending</span>
      </div>
      <div id="pending-list" class="px-3 pb-2 space-y-1"></div>
    </div>

    <!-- Connections list -->
    <div class="border-b border-edge">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="w-1.5 h-1.5 rounded-full bg-mesh-green"></div>
        <span class="text-[10px] text-mesh-green font-medium uppercase tracking-wider">Connections</span>
        <span class="text-[10px] text-muted ml-auto" id="sidebar-conn-count">0</span>
      </div>
      <div id="connections-list" class="px-3 pb-2 space-y-0.5 max-h-40 overflow-y-auto">
        <p class="text-[10px] text-muted italic">No connections</p>
      </div>
    </div>

    <!-- Activity feed -->
    <div class="flex-1 flex flex-col min-h-0">
      <div class="px-3 py-2 flex items-center gap-2 shrink-0">
        <div class="w-1.5 h-1.5 rounded-full bg-solar-400"></div>
        <span class="text-[10px] text-solar-400 font-medium uppercase tracking-wider">Activity</span>
      </div>
      <div id="activity-feed" class="px-3 pb-2 space-y-0.5 overflow-y-auto flex-1">
        <p class="text-[10px] text-muted italic">Waiting for activity...</p>
      </div>
    </div>

    <!-- NAT status footer -->
    <div id="nat-status" class="px-3 py-2 border-t border-edge hidden">
      <div class="flex items-center gap-1.5">
        <div class="w-1 h-1 rounded-full bg-mesh-yellow"></div>
        <span class="text-[9px] text-muted">NAT detected — using relay</span>
      </div>
    </div>
  </div>

  <!-- ================================================================== -->
  <!-- CONSTELLATION — Full-area SVG + floating overlays                    -->
  <!-- ================================================================== -->
  <div id="constellation-area" class="flex-1 relative bg-ink overflow-hidden">

    <!-- SVG fills entire area -->
    <svg id="mesh-svg" class="absolute inset-0 w-full h-full"></svg>

    <!-- Hover tooltip -->
    <div id="mesh-tooltip" class="absolute hidden bg-slab border border-edge rounded px-2.5 py-1.5 text-[10px] z-30 pointer-events-none shadow-lg max-w-[200px]">
      <div class="text-bright font-medium" id="mesh-tooltip-name"></div>
      <div class="text-muted mt-0.5" id="mesh-tooltip-bio"></div>
    </div>

    <!-- Empty state -->
    <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center text-center select-none pointer-events-none z-10">
      <div class="relative mb-5">
        <div class="w-20 h-20 rounded-full border border-solar-500/20 flex items-center justify-center" style="box-shadow: 0 0 40px 4px rgba(221,128,64,0.08)">
          <div class="w-14 h-14 rounded-full border border-solar-500/15 flex items-center justify-center">
            <div class="w-4 h-4 rounded-full bg-solar-500/60 pulse-dot"></div>
          </div>
        </div>
      </div>
      <p class="text-pale text-sm font-medium">WormHole</p>
      <p class="text-muted text-xs mt-1">connect to an agent to begin</p>
      <p class="text-faint text-[10px] mt-0.5">the constellation will form around you</p>
    </div>

    <!-- Floating compose bar -->
    <div id="compose-bar" class="absolute bottom-4 left-4 right-4 z-30">
      <form id="compose-form">
        <div id="compose-container" class="bg-dim/90 backdrop-blur-md border border-edge rounded-xl transition-colors focus-within:border-solar-500/40 shadow-xl">
          <!-- Route pill row -->
          <div class="flex items-center px-3 pt-2.5 pb-0">
            <div class="relative" id="target-dropdown-wrap">
              <button type="button" id="target-dropdown-btn" onclick="toggleDropdown()"
                class="flex items-center gap-1.5 text-[11px] text-pale hover:text-bright bg-edge/40 hover:bg-edge/70 rounded-full px-2.5 py-1 transition-colors">
                <svg id="route-icon" width="10" height="10" viewBox="0 0 10 10" class="text-mesh-green shrink-0"><circle cx="5" cy="5" r="3" fill="currentColor"/></svg>
                <span id="target-label">auto-route</span>
                <svg width="8" height="8" viewBox="0 0 8 8" class="text-muted shrink-0"><path d="M2 3l2 2 2-2" stroke="currentColor" stroke-width="1" fill="none"/></svg>
              </button>
              <div id="target-dropdown-menu" class="dropdown-menu absolute bottom-full left-0 mb-1 w-52 bg-slab border border-edge rounded-lg shadow-xl z-30 py-1 max-h-48 overflow-y-auto"></div>
            </div>
          </div>
          <!-- Textarea + send button -->
          <div class="flex items-end gap-2 px-3 pt-1.5 pb-2.5">
            <textarea name="content" id="compose-input" rows="1"
              placeholder="Send a message..."
              class="flex-1 bg-transparent text-sm text-bright placeholder-muted resize-none leading-relaxed p-0 border-0 focus:ring-0"
              style="max-height:120px;outline:none"
              oninput="autoGrow(this)"></textarea>
            <button type="submit" id="send-btn"
              class="w-8 h-8 rounded-full bg-solar-500 hover:bg-solar-400 text-ink flex items-center justify-center transition-colors disabled:opacity-30 disabled:cursor-not-allowed shrink-0 mb-0.5"
              title="Send">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
            </button>
          </div>
        </div>
        <input type="hidden" name="target" id="target-value" value="auto">
        <div class="flex items-center justify-end mt-1 px-1">
          <span class="text-[9px] text-faint"><kbd class="text-muted">Shift+Enter</kbd> newline &middot; <kbd class="text-muted">Enter</kbd> send</span>
        </div>
      </form>
    </div>
  </div>

  <!-- ================================================================== -->
  <!-- RIGHT PANEL — Message Timeline                                      -->
  <!-- ================================================================== -->
  <div id="right-panel" class="relative bg-dim border-l border-edge flex flex-col shrink-0 overflow-hidden hidden md:flex z-20" style="width:320px;min-width:200px;max-width:50vw">
    <!-- Drag handle for resizing -->
    <div id="right-panel-handle" class="absolute left-0 top-0 bottom-0 w-1.5 cursor-col-resize hover:bg-solar-500/30 active:bg-solar-500/40 transition-colors z-30" style="left:0"></div>
    <div class="px-3 py-2.5 border-b border-edge flex items-center justify-between">
      <div class="flex items-center gap-2">
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M1 3h10M1 6h7M1 9h5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" class="text-solar-400"/></svg>
        <span class="text-[11px] text-solar-400 font-medium uppercase tracking-wider">Messages</span>
        <span id="timeline-count" class="text-[10px] text-muted bg-edge/50 rounded-full px-1.5 py-0.5 min-w-[18px] text-center">0</span>
      </div>
      <button id="timeline-clear-btn" onclick="clearTimeline()" class="text-faint hover:text-muted transition-colors" title="Clear messages">
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M3 3l6 6M9 3l-6 6" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/></svg>
      </button>
    </div>
    <div id="timeline-scroll" class="flex-1 overflow-y-auto px-2.5 py-2 space-y-2"></div>
  </div>

  <!-- ================================================================== -->
  <!-- MOBILE DRAWER — Left panel on small screens                         -->
  <!-- ================================================================== -->
  <div id="mobile-drawer-overlay" class="drawer-overlay fixed inset-0 bg-black/60 z-50 md:hidden" onclick="toggleMobileDrawer()">
    <div class="drawer-panel absolute left-0 top-0 bottom-0 w-72 bg-dim border-r border-edge flex flex-col overflow-hidden" onclick="event.stopPropagation()" style="transform:translateX(-100%)">
      <div class="px-3 py-2.5 border-b border-edge flex items-center justify-between">
        <span class="text-[10px] text-solar-400 font-medium uppercase tracking-wider">WormHole</span>
        <button onclick="toggleMobileDrawer()" class="text-muted hover:text-bright text-xs">&times;</button>
      </div>
      <!-- Connected agents (mobile) -->
      <div class="flex-1 overflow-y-auto px-3 py-2 space-y-1" id="mobile-connections-list"></div>
      <!-- Activity feed (mobile) -->
      <div class="border-t border-edge">
        <div class="px-3 py-2 flex items-center gap-2">
          <div class="w-1.5 h-1.5 rounded-full bg-solar-400"></div>
          <span class="text-[10px] text-solar-400 font-medium uppercase tracking-wider">Activity</span>
        </div>
        <div id="mobile-activity-feed" class="px-3 pb-2 space-y-0.5 max-h-36 overflow-y-auto"></div>
      </div>
    </div>
  </div>

</div>

<!-- ================================================================== -->
<!-- WALLET MODAL                                                        -->
<!-- ================================================================== -->
<div id="wallet-modal" class="fixed inset-0 bg-black/70 backdrop-blur-sm z-[60] hidden flex items-center justify-center" onclick="if(event.target===this)closeWalletModal()">
  <div class="bg-dim border border-edge rounded-xl shadow-2xl w-full max-w-md mx-4 overflow-hidden">
    <div class="px-5 pt-5 pb-3 border-b border-edge flex items-center justify-between">
      <div class="flex items-center gap-2">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-solar-400">
          <rect x="2" y="6" width="20" height="14" rx="2"/><path d="M2 10h20"/><circle cx="18" cy="15" r="1"/>
        </svg>
        <span class="text-sm font-semibold text-bright">Wallet</span>
      </div>
      <button onclick="closeWalletModal()" class="text-muted hover:text-bright transition-colors text-lg">&times;</button>
    </div>

    <!-- Main wallet tabs: Balances vs Identity -->
    <div class="flex border-b border-edge">
      <button id="wallet-main-tab-balances" onclick="walletMainTab('balances')"
        class="flex-1 text-[10px] font-semibold py-2.5 transition-colors bg-slab/50 text-bright border-b-2 border-solar-400">
        Balances
      </button>
      <button id="wallet-main-tab-send" onclick="walletMainTab('send')"
        class="flex-1 text-[10px] font-semibold py-2.5 transition-colors text-muted hover:text-pale border-b-2 border-transparent">
        Send
      </button>
      <button id="wallet-main-tab-identity" onclick="walletMainTab('identity')"
        class="flex-1 text-[10px] font-semibold py-2.5 transition-colors text-muted hover:text-pale border-b-2 border-transparent">
        Identity
      </button>
    </div>

    <!-- ======== BALANCES PANEL ======== -->
    <div id="wallet-panel-balances" class="px-5 py-4 space-y-3 max-h-[60vh] overflow-y-auto">
      <!-- Solana address -->
      <div class="flex items-center gap-2">
        <span class="text-[10px] text-muted uppercase tracking-wider">Solana</span>
        <span id="wallet-sol-addr" class="text-[10px] text-pale font-mono flex-1 truncate"></span>
        <button onclick="copyWalletAddr()" class="text-muted hover:text-bright transition-colors" title="Copy address">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
        </button>
      </div>
      <div id="wallet-no-solana" class="hidden text-[11px] text-muted italic py-4 text-center">
        No Solana wallet available
      </div>

      <!-- SOL balance -->
      <div id="wallet-balances-list" class="space-y-1.5">
        <div class="flex items-center justify-between px-3 py-2 bg-slab/50 rounded-lg">
          <span class="text-[11px] text-bright font-medium">SOL</span>
          <span id="wallet-sol-balance" class="text-[11px] text-pale font-mono">--</span>
        </div>
      </div>

      <!-- Token balances -->
      <div id="wallet-token-balances" class="space-y-1"></div>

      <!-- Refresh button -->
      <button onclick="refreshWalletBalances()" id="wallet-refresh-btn"
        class="w-full text-[10px] text-muted hover:text-pale py-1.5 transition-colors flex items-center justify-center gap-1">
        <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/></svg>
        Refresh balances
      </button>
    </div>

    <!-- ======== SEND PANEL ======== -->
    <div id="wallet-panel-send" class="px-5 py-4 space-y-3 hidden">
      <div>
        <label class="text-[10px] text-muted uppercase tracking-wider mb-1 block">Recipient</label>
        <select id="wallet-send-recipient" class="w-full bg-slab border border-edge rounded-lg px-3 py-2 text-[11px] text-bright focus:border-solar-500/60 transition-colors">
          <option value="">Select connected agent...</option>
        </select>
      </div>
      <div class="flex gap-2">
        <div class="flex-1">
          <label class="text-[10px] text-muted uppercase tracking-wider mb-1 block">Amount</label>
          <input type="number" id="wallet-send-amount" step="any" min="0" placeholder="0.0"
            class="w-full bg-slab border border-edge rounded-lg px-3 py-2 text-[11px] text-bright placeholder-muted focus:border-solar-500/60 transition-colors">
        </div>
        <div class="w-28">
          <label class="text-[10px] text-muted uppercase tracking-wider mb-1 block">Token</label>
          <select id="wallet-send-token" class="w-full bg-slab border border-edge rounded-lg px-3 py-2 text-[11px] text-bright focus:border-solar-500/60 transition-colors">
            <option value="SOL">SOL</option>
          </select>
        </div>
      </div>
      <button onclick="walletSend()" id="wallet-send-btn"
        class="w-full bg-solar-600/80 hover:bg-solar-500 text-ink text-[11px] font-bold px-4 py-2.5 rounded-lg transition-colors">
        Send
      </button>
      <div id="wallet-send-result" class="hidden text-[10px] font-mono bg-slab/50 rounded-lg px-3 py-2 break-all"></div>
    </div>

    <!-- ======== IDENTITY PANEL ======== -->
    <div id="wallet-panel-identity" class="px-5 py-4 space-y-4 hidden">
      <p class="text-[11px] text-pale leading-relaxed">
        Sign a deterministic challenge with your Solana wallet to derive a mesh identity.
        The same wallet always produces the same agent ID on any device.
      </p>

      <!-- Tab buttons: Extension vs Mobile QR -->
      <div class="flex border border-edge rounded-lg overflow-hidden">
        <button id="wallet-tab-ext" onclick="walletTab('ext')"
          class="flex-1 text-[10px] font-semibold py-2 transition-colors bg-slab text-bright">
          Browser Extension
        </button>
        <button id="wallet-tab-qr" onclick="walletTab('qr')"
          class="flex-1 text-[10px] font-semibold py-2 transition-colors text-muted hover:text-pale">
          Mobile QR
        </button>
      </div>

      <!-- Extension flow -->
      <div id="wallet-ext-panel">
        <div class="bg-mesh-yellow/5 border border-mesh-yellow/20 rounded-lg px-3 py-2 mb-3">
          <p class="text-[10px] text-mesh-yellow">This will change your identity and disconnect existing peers.</p>
        </div>
        <label class="flex items-center gap-2 cursor-pointer mb-3">
          <input type="checkbox" id="wallet-remember" class="w-3.5 h-3.5 rounded border-edge bg-slab accent-solar-500">
          <span class="text-[11px] text-pale">Remember on this device</span>
        </label>
        <div class="flex gap-2">
          <button id="wallet-connect-btn" onclick="walletAuth()"
            class="flex-1 bg-solar-600/80 hover:bg-solar-500 text-ink text-[11px] font-bold px-4 py-2.5 rounded-lg transition-colors">
            Connect Wallet
          </button>
          <button id="wallet-disconnect-btn" onclick="walletDisconnect()"
            class="hidden bg-mesh-red/10 hover:bg-mesh-red/20 text-mesh-red text-[11px] font-bold px-4 py-2.5 rounded-lg transition-colors border border-mesh-red/20">
            Revert
          </button>
        </div>
        <p class="text-[10px] text-muted mt-2">Phantom, Solflare, Backpack, or any Solana wallet extension.</p>
      </div>

      <!-- Mobile QR flow -->
      <div id="wallet-qr-panel" class="hidden">
        <div class="bg-mesh-yellow/5 border border-mesh-yellow/20 rounded-lg px-3 py-2 mb-3">
          <p class="text-[10px] text-mesh-yellow">Scan with your phone camera, then sign in your wallet app.</p>
        </div>
        <div id="wallet-qr-idle">
          <label class="flex items-center gap-2 cursor-pointer mb-3">
            <input type="checkbox" id="wallet-qr-remember" class="w-3.5 h-3.5 rounded border-edge bg-slab accent-solar-500">
            <span class="text-[11px] text-pale">Remember on this device</span>
          </label>
          <button onclick="startQRSession()"
            class="w-full bg-solar-600/80 hover:bg-solar-500 text-ink text-[11px] font-bold px-4 py-2.5 rounded-lg transition-colors">
            Generate QR Code
          </button>
        </div>
        <div id="wallet-qr-active" class="hidden">
          <div id="wallet-qr-code" class="flex justify-center mb-2"></div>
          <p id="wallet-qr-url" class="text-[9px] text-muted text-center break-all select-all mb-2"></p>
          <div class="flex items-center justify-center gap-2">
            <div class="w-1.5 h-1.5 rounded-full bg-solar-400 pulse-dot"></div>
            <span class="text-[10px] text-pale">Waiting for signature from mobile...</span>
          </div>
        </div>
        <div id="wallet-qr-done" class="hidden text-center py-2">
          <p class="text-[11px] text-mesh-green font-medium">Signed! Applying identity...</p>
        </div>
      </div>

      <!-- Status (shared) -->
      <div id="wallet-status" class="hidden text-[11px] text-mesh-green font-mono bg-mesh-green/5 border border-mesh-green/20 rounded-lg px-3 py-2"></div>
    </div>
  </div>
</div>

<style>
  /* Constellation-specific animations */
  @keyframes ring-expand {
    0% { r: 8; opacity: 0.8; stroke-width: 2; }
    100% { r: 30; opacity: 0; stroke-width: 0.5; }
  }
  @keyframes scatter-particle {
    0% { opacity: 0.8; }
    100% { opacity: 0; }
  }
  /* Mobile drawer slides from left */
  .drawer-panel { transition: transform 0.3s ease; }
  .drawer-overlay.active .drawer-panel { transform: translateX(0) !important; }
  /* Timeline sidebar */
  @keyframes timeline-in { from { opacity: 0; transform: translateX(12px); } to { opacity: 1; transform: translateX(0); } }
  .timeline-enter { animation: timeline-in 0.25s ease-out forwards; }
  .truncated-content { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
  .truncated-content.expanded { -webkit-line-clamp: unset; }
  .connector-line { pointer-events: none; }
  body.resizing-panel, body.resizing-panel * { cursor: col-resize !important; user-select: none !important; }
</style>

<script>
// =========================================================================
// State
// =========================================================================
const pendingSection = document.getElementById('pending-section');
const pendingListEl = document.getElementById('pending-list');
const discoveredList = document.getElementById('discovered-list');
const connectionsList = document.getElementById('connections-list');
const mobileConnectionsList = document.getElementById('mobile-connections-list');
const composeForm = document.getElementById('compose-form');
const composeInput = document.getElementById('compose-input');
const sendBtn = document.getElementById('send-btn');
const connectForm = document.getElementById('connect-form');
const activityFeed = document.getElementById('activity-feed');
const mobileActivityFeed = document.getElementById('mobile-activity-feed');
const targetValue = document.getElementById('target-value');
const targetLabel = document.getElementById('target-label');
const targetMenu = document.getElementById('target-dropdown-menu');
const constellationArea = document.getElementById('constellation-area');
const emptyState = document.getElementById('empty-state');

// Diff-tracking maps
const renderedConns = new Map();
const renderedConnsMobile = new Map();
const renderedDiscovered = new Map();
const renderedPending = new Map();

// SVG engine — persistent element refs
const svgRefs = {
  defs: null,
  lineGroup: null,
  labelGroup: null,
  nodeGroup: null,
  particleGroup: null,
  hitGroup: null,
  connectorGroup: null,
  centerNode: null,
  centerGlow: null,
  centerLabel: null,
  centerAgentLabel: null,
  hintText: null,
  lines: new Map(),       // agent_id -> { base, glow } (two lines — base dashed + glow overlay)
  nodes: new Map(),       // agent_id -> { circle, label, hit, glow }
  lineHits: new Map(),    // agent_id -> invisible thick hit area for hover
};
const nodePositions = new Map();  // agent_id -> { x, y }
let centerPos = { x: 0, y: 0 };
let svgW = 0, svgH = 0;
let currentConns = [];

// Message visualization
const messageVisuals = new Map();  // message_id -> { lastUpdateIndex }
const lineWaveTimers = new Map();  // agent_id -> { raf, startTime }

// Orbital planet system
const orbitingPlanets = new Map(); // agent_id -> Map<message_id, {el, trail[], angle, speed, orbitR}>
const orbitAnimFrames = new Map(); // agent_id -> { raf, lastTime }
const orbitPlanetColors = ['#fbbf24', '#22d3ee', '#a78bfa', '#f472b6', '#34d399', '#fb923c', '#60a5fa'];

// Deterministic color for an agent — consistent across reloads
function agentColor(agentId) {
  if (!agentId) return orbitPlanetColors[0];
  let hash = 0;
  for (let i = 0; i < agentId.length; i++) hash = ((hash << 5) - hash + agentId.charCodeAt(i)) | 0;
  return orbitPlanetColors[Math.abs(hash) % orbitPlanetColors.length];
}
const lineMessageHistory = new Map(); // agent_id -> [{ content, status, direction, time }]

// Polling state
let prevPollData = null;
let activityItems = [];
const MAX_ACTIVITY = 30;
let totalActiveAgents = 0;
const prevAgentCounts = new Map();
let qrInitialized = false;
let qrExpanded = false;

// Timeline sidebar state
const timelineScroll = document.getElementById('timeline-scroll');
const timelineCountEl = document.getElementById('timeline-count');
const renderedTimeline = new Map(); // message_id -> DOM element
const dismissedTimeline = new Set(); // message_ids cleared by user
let timelineConnectorLine = null;
let highlightedTimelineAgent = null;

// =========================================================================
// Utilities
// =========================================================================
function shortId(id) {
  if (!id) return '?';
  if (id.length > 16) return id.slice(0, 8) + '...' + id.slice(-4);
  return id;
}

let selfAgentId = null;  // set from poll data
function agentLabel(obj) {
  if (!obj) return '?';
  const id = obj.agent_id || obj.from_agent_id;
  if (id && id === selfAgentId) return 'You';
  return (obj.display_name || obj.from_display_name || '').trim()
    || (obj.bio || obj.from_bio || '').trim().slice(0, 30)
    || shortId(id);
}

function timeAgo(iso) {
  if (!iso) return '';
  const s = Math.floor((Date.now() - new Date(iso).getTime()) / 1000);
  if (s < 5) return 'now';
  if (s < 60) return s + 's';
  if (s < 3600) return Math.floor(s/60) + 'm';
  if (s < 86400) return Math.floor(s/3600) + 'h';
  return Math.floor(s/86400) + 'd';
}

function esc(t) {
  const d = document.createElement('div');
  d.textContent = t;
  return d.innerHTML;
}

function ajaxPost(url, body) {
  return fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'X-Requested-With': 'XMLHttpRequest' },
    body: JSON.stringify(body),
  }).then(r => {
    if (!r.ok) return { success: false, error: `Server error (${r.status})` };
    return r.json();
  });
}

function autoGrow(el) {
  el.style.height = 'auto';
  el.style.height = Math.min(el.scrollHeight, 120) + 'px';
}

function svgEl(tag, attrs) {
  const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
  if (attrs) Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, String(v)));
  return el;
}

// =========================================================================
// QR Code
// =========================================================================
function toggleQR() {
  const content = document.getElementById('qr-content');
  const chevron = document.getElementById('qr-chevron');
  qrExpanded = !qrExpanded;
  content.classList.toggle('hidden', !qrExpanded);
  chevron.style.transform = qrExpanded ? 'rotate(180deg)' : '';
}

function initQR(lanUrl) {
  if (qrInitialized) return;
  const el = document.getElementById('qr-code');
  const urlEl = document.getElementById('qr-url');
  const unavailEl = document.getElementById('qr-unavailable');
  if (!lanUrl) { unavailEl.classList.remove('hidden'); return; }
  qrInitialized = true;
  urlEl.textContent = lanUrl;
  el.innerHTML = '';
  const style = getComputedStyle(document.documentElement);
  new QRCode(el, {
    text: lanUrl, width: 120, height: 120,
    colorDark: style.getPropertyValue('--qr-fg').trim() || '#e2e2ea',
    colorLight: style.getPropertyValue('--qr-bg').trim() || '#111113',
    correctLevel: QRCode.CorrectLevel.M,
  });
  if (!qrExpanded) toggleQR();
}

function onThemeChange() {
  if (qrInitialized) {
    qrInitialized = false;
    initQR(document.getElementById('qr-url').textContent);
  }
  // Force SVG re-render for theme-dependent colors
  rebuildSVG();
}

// =========================================================================
// Custom dropdown
// =========================================================================
let dropdownOpen = false;

function toggleDropdown() {
  dropdownOpen = !dropdownOpen;
  document.getElementById('target-dropdown-wrap').classList.toggle('dropdown-open', dropdownOpen);
}

function selectTarget(el) {
  const val = el.dataset.value;
  const label = el.textContent.trim();
  targetValue.value = val;
  targetLabel.textContent = label;
  const iconEl = document.getElementById('route-icon');
  if (val === 'broadcast') {
    iconEl.innerHTML = '<circle cx="5" cy="3" r="1.8" fill="currentColor"/><circle cx="2.5" cy="7.5" r="1.8" fill="currentColor"/><circle cx="7.5" cy="7.5" r="1.8" fill="currentColor"/>';
    iconEl.setAttribute('class', 'text-mesh-yellow shrink-0');
  } else if (val === 'auto') {
    iconEl.innerHTML = '<circle cx="5" cy="5" r="3" fill="currentColor"/>';
    iconEl.setAttribute('class', 'text-mesh-green shrink-0');
  } else {
    iconEl.innerHTML = '<circle cx="5" cy="5" r="3" fill="currentColor"/>';
    iconEl.setAttribute('class', 'text-mesh-blue shrink-0');
  }
  dropdownOpen = false;
  document.getElementById('target-dropdown-wrap').classList.remove('dropdown-open');
}

document.addEventListener('click', (e) => {
  if (!e.target.closest('#target-dropdown-wrap') && dropdownOpen) {
    dropdownOpen = false;
    document.getElementById('target-dropdown-wrap').classList.remove('dropdown-open');
  }
});

function updateDropdownOptions(conns) {
  const cur = targetValue.value;
  let html = `<div class="dropdown-option px-3 py-1.5 text-[11px] text-pale hover:bg-edge/50 cursor-pointer flex items-center gap-2 transition-colors rounded mx-1"
    data-value="auto" onclick="selectTarget(this)">
    <svg width="10" height="10" viewBox="0 0 10 10" class="text-mesh-green shrink-0"><circle cx="5" cy="5" r="3" fill="currentColor"/></svg>
    auto-route
  </div>
  <div class="dropdown-option px-3 py-1.5 text-[11px] text-pale hover:bg-edge/50 cursor-pointer flex items-center gap-2 transition-colors rounded mx-1"
    data-value="broadcast" onclick="selectTarget(this)">
    <svg width="10" height="10" viewBox="0 0 10 10" class="text-mesh-yellow shrink-0"><circle cx="5" cy="3" r="1.8" fill="currentColor"/><circle cx="2.5" cy="7.5" r="1.8" fill="currentColor"/><circle cx="7.5" cy="7.5" r="1.8" fill="currentColor"/></svg>
    broadcast all
  </div>`;
  if (conns.length > 0) {
    html += `<div class="border-t border-edge my-1 mx-2"></div>`;
    conns.forEach(c => {
      const dead = c.health_status === 'unreachable';
      const dotClass = dead ? 'text-muted shrink-0' : 'text-mesh-blue shrink-0';
      const textClass = dead ? 'text-muted' : 'text-pale';
      const hoverClass = dead ? '' : 'hover:bg-edge/50 cursor-pointer';
      const clickAttr = dead ? '' : 'onclick="selectTarget(this)"';
      const suffix = dead ? ' <span class="text-[9px] text-mesh-red">\u2298</span>' : '';
      html += `<div class="dropdown-option px-3 py-1.5 text-[11px] ${textClass} ${hoverClass} flex items-center gap-2 transition-colors rounded mx-1"
        data-value="${c.agent_id}" ${clickAttr}>
        <svg width="10" height="10" viewBox="0 0 10 10" class="${dotClass}"><circle cx="5" cy="5" r="3" fill="currentColor"/></svg>
        ${esc(agentLabel(c))}${suffix}
      </div>`;
    });
  }
  targetMenu.innerHTML = html;
  const validValues = ['auto', 'broadcast', ...conns.map(c => c.agent_id)];
  if (!validValues.includes(cur)) {
    targetValue.value = 'auto';
    targetLabel.textContent = 'auto-route';
    const iconEl = document.getElementById('route-icon');
    iconEl.innerHTML = '<circle cx="5" cy="5" r="3" fill="currentColor"/>';
    iconEl.setAttribute('class', 'text-mesh-green shrink-0');
  }
}

// =========================================================================
// Activity feed
// =========================================================================
function addActivity(icon, color, text) {
  const item = { icon, color, text, time: new Date().toISOString() };
  activityItems.unshift(item);
  if (activityItems.length > MAX_ACTIVITY) activityItems.pop();
  renderActivityFeed();
}

function renderActivityFeed() {
  const html = activityItems.map(a =>
    `<div class="flex items-center gap-1.5 text-[10px] feed-in">
      <span class="${a.color}">${a.icon}</span>
      <span class="text-pale truncate flex-1">${esc(a.text)}</span>
      <span class="text-faint shrink-0">${timeAgo(a.time)}</span>
    </div>`
  ).join('');
  const placeholder = activityItems.length === 0
    ? '<p class="text-[10px] text-muted italic">Waiting for activity...</p>' : '';
  activityFeed.innerHTML = html || placeholder;
  if (mobileActivityFeed) mobileActivityFeed.innerHTML = html || placeholder;
}

// =========================================================================
// Incremental SVG Engine — Constellation
// =========================================================================
function initSVG() {
  const svg = document.getElementById('mesh-svg');
  if (!svg) return;
  svg.innerHTML = '';

  // Defs
  svgRefs.defs = svgEl('defs');
  svgRefs.defs.innerHTML = `
    <filter id="glow" x="-100%" y="-100%" width="300%" height="300%">
      <feGaussianBlur stdDeviation="6" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
    <filter id="glow-sm" x="-100%" y="-100%" width="300%" height="300%">
      <feGaussianBlur stdDeviation="3" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
    <filter id="line-glow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="2.5" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>`;
  svg.appendChild(svgRefs.defs);

  // Layered groups: lines → edgeLabels → nodes → particles → hit areas
  svgRefs.lineGroup = svgEl('g');
  svgRefs.labelGroup = svgEl('g');
  svgRefs.nodeGroup = svgEl('g');
  svgRefs.particleGroup = svgEl('g');
  svgRefs.hitGroup = svgEl('g');
  svgRefs.connectorGroup = svgEl('g');
  svg.appendChild(svgRefs.lineGroup);
  svg.appendChild(svgRefs.labelGroup);
  svg.appendChild(svgRefs.nodeGroup);
  svg.appendChild(svgRefs.particleGroup);
  svg.appendChild(svgRefs.hitGroup);
  svg.appendChild(svgRefs.connectorGroup);

  // Center glow
  svgRefs.centerGlow = svgEl('circle', {
    cx: 0, cy: 0, r: 34,
    fill: '#dd8040', opacity: 0.1,
    filter: 'url(#glow)',
  });
  svgRefs.centerGlow.classList.add('mesh-glow-pulse');
  svgRefs.nodeGroup.appendChild(svgRefs.centerGlow);

  // Center node
  svgRefs.centerNode = svgEl('circle', {
    cx: 0, cy: 0, r: 14,
    fill: '#dd8040',
  });
  svgRefs.centerNode.style.transition = 'r 0.4s ease';
  svgRefs.nodeGroup.appendChild(svgRefs.centerNode);

  // Center label
  svgRefs.centerLabel = svgEl('text', {
    x: 0, y: 30,
    'text-anchor': 'middle',
    fill: 'rgb(var(--c-pale))',
    'font-size': '9',
    'font-family': 'JetBrains Mono, monospace',
  });
  svgRefs.centerLabel.textContent = 'You';
  svgRefs.nodeGroup.appendChild(svgRefs.centerLabel);

  // Center agent count label (shown when agents > 0)
  svgRefs.centerAgentLabel = svgEl('text', {
    x: 0, y: 42,
    'text-anchor': 'middle',
    fill: '#22d3ee',
    'font-size': '7',
    'font-family': 'JetBrains Mono, monospace',
    opacity: 0,
  });
  svgRefs.centerAgentLabel.style.transition = 'opacity 0.3s ease';
  svgRefs.nodeGroup.appendChild(svgRefs.centerAgentLabel);

  // Hint text (shown when no connections)
  svgRefs.hintText = svgEl('text', {
    x: 0, y: 52,
    'text-anchor': 'middle',
    fill: 'rgb(var(--c-muted))',
    'font-size': '9',
    'font-family': 'JetBrains Mono, monospace',
  });
  svgRefs.hintText.textContent = 'no peers connected';
  svgRefs.nodeGroup.appendChild(svgRefs.hintText);

  updateSVGLayout();
}

function updateSVGLayout() {
  const svg = document.getElementById('mesh-svg');
  const area = constellationArea;
  if (!svg || !area) return;

  const rect = area.getBoundingClientRect();
  svgW = rect.width || 800;
  svgH = rect.height || 600;
  svg.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);

  // Center node offset upward to leave room for compose bar
  centerPos = { x: svgW / 2, y: svgH * 0.42 };

  // Update center elements
  if (svgRefs.centerNode) {
    svgRefs.centerNode.setAttribute('cx', centerPos.x);
    svgRefs.centerNode.setAttribute('cy', centerPos.y);
  }
  if (svgRefs.centerGlow) {
    svgRefs.centerGlow.setAttribute('cx', centerPos.x);
    svgRefs.centerGlow.setAttribute('cy', centerPos.y);
  }
  if (svgRefs.centerLabel) {
    svgRefs.centerLabel.setAttribute('x', centerPos.x);
    svgRefs.centerLabel.setAttribute('y', centerPos.y + 30);
  }
  if (svgRefs.centerAgentLabel) {
    svgRefs.centerAgentLabel.setAttribute('x', centerPos.x);
    svgRefs.centerAgentLabel.setAttribute('y', centerPos.y + 42);
  }
  if (svgRefs.hintText) {
    svgRefs.hintText.setAttribute('x', centerPos.x);
    svgRefs.hintText.setAttribute('y', centerPos.y + 52);
  }

  // Recalculate peer positions
  layoutPeers(currentConns);
}

function layoutPeers(conns) {
  const radius = Math.min(svgW, svgH) * 0.3;
  nodePositions.clear();

  conns.forEach((c, i) => {
    const angle = conns.length === 1 ? -Math.PI / 2
      : (2 * Math.PI * i / conns.length) - Math.PI / 2;
    const x = centerPos.x + radius * Math.cos(angle);
    const y = centerPos.y + radius * Math.sin(angle);
    nodePositions.set(c.agent_id, { x, y });
  });

  // Update existing SVG element positions
  for (const [agentId, pos] of nodePositions) {
    const refs = svgRefs.nodes.get(agentId);
    if (refs) {
      refs.circle.setAttribute('cx', pos.x);
      refs.circle.setAttribute('cy', pos.y);
      refs.label.setAttribute('x', pos.x);
      refs.label.setAttribute('y', pos.y + 26);
      refs.hit.setAttribute('cx', pos.x);
      refs.hit.setAttribute('cy', pos.y);
      if (refs.glow) {
        refs.glow.setAttribute('cx', pos.x);
        refs.glow.setAttribute('cy', pos.y);
      }
      if (refs.badge) {
        refs.badge.setAttribute('x', pos.x);
        refs.badge.setAttribute('y', pos.y);
      }
    }
    const lineRefs = svgRefs.lines.get(agentId);
    if (lineRefs) {
      for (const el of [lineRefs.base, lineRefs.glow]) {
        el.setAttribute('x1', centerPos.x);
        el.setAttribute('y1', centerPos.y);
        el.setAttribute('x2', pos.x);
        el.setAttribute('y2', pos.y);
      }
    }
    const lineHit = svgRefs.lineHits.get(agentId);
    if (lineHit) {
      lineHit.setAttribute('x1', centerPos.x);
      lineHit.setAttribute('y1', centerPos.y);
      lineHit.setAttribute('x2', pos.x);
      lineHit.setAttribute('y2', pos.y);
    }
  }

  // Sync orbit positions when nodes move
  syncOrbitPositions();
}

function updateConstellationNodes(conns) {
  currentConns = conns;
  const currentIds = new Set(conns.map(c => c.agent_id));

  // Show/hide hint + empty state
  if (svgRefs.hintText) {
    svgRefs.hintText.setAttribute('display', conns.length === 0 ? '' : 'none');
  }
  if (emptyState) {
    emptyState.style.display = conns.length === 0 ? '' : 'none';
  }

  // Remove stale nodes
  for (const [id, refs] of svgRefs.nodes) {
    if (!currentIds.has(id)) {
      refs.circle.remove();
      refs.label.remove();
      refs.hit.remove();
      if (refs.glow) refs.glow.remove();
      if (refs.badge) refs.badge.remove();
      // Clean up any orbiting planets for this node
      const planets = orbitingPlanets.get(id);
      if (planets) {
        for (const [, p] of planets) { p.el.remove(); p.trail.forEach(t => t.remove()); }
        orbitingPlanets.delete(id);
      }
      const anim = orbitAnimFrames.get(id);
      if (anim) { cancelAnimationFrame(anim.raf); orbitAnimFrames.delete(id); }
      svgRefs.nodes.delete(id);
    }
  }
  for (const [id, refs] of svgRefs.lines) {
    if (!currentIds.has(id)) {
      refs.base.remove();
      refs.glow.remove();
      svgRefs.lines.delete(id);
    }
  }
  for (const [id, hit] of svgRefs.lineHits) {
    if (!currentIds.has(id)) {
      hit.remove();
      svgRefs.lineHits.delete(id);
    }
  }

  // Layout positions first
  layoutPeers(conns);

  // Add new nodes + lines
  conns.forEach(c => {
    const pos = nodePositions.get(c.agent_id);
    if (!pos) return;

    // Line (base dashed + glow overlay + invisible hit area)
    if (!svgRefs.lines.has(c.agent_id)) {
      const base = svgEl('line', {
        x1: centerPos.x, y1: centerPos.y, x2: pos.x, y2: pos.y,
        stroke: 'rgb(var(--c-edge))', 'stroke-width': 1.5, 'stroke-dasharray': '5,4',
        'stroke-linecap': 'round',
      });
      const glow = svgEl('line', {
        x1: centerPos.x, y1: centerPos.y, x2: pos.x, y2: pos.y,
        stroke: '#dd8040', 'stroke-width': 2, opacity: 0,
        'stroke-linecap': 'round', filter: 'url(#line-glow)',
      });
      glow.style.transition = 'opacity 0.3s ease';
      svgRefs.lineGroup.appendChild(base);
      svgRefs.lineGroup.appendChild(glow);
      svgRefs.lines.set(c.agent_id, { base, glow });

      // Invisible wide hit area for hover
      const lineHit = svgEl('line', {
        x1: centerPos.x, y1: centerPos.y, x2: pos.x, y2: pos.y,
        stroke: 'transparent', 'stroke-width': 16, class: 'cursor-pointer',
      });
      lineHit.addEventListener('mouseenter', (e) => showLineTooltip(c.agent_id, e));
      lineHit.addEventListener('mousemove', (e) => moveMeshTooltip(e));
      lineHit.addEventListener('mouseleave', () => hideMeshTooltip());
      svgRefs.hitGroup.appendChild(lineHit);
      svgRefs.lineHits.set(c.agent_id, lineHit);
    }

    // Node
    if (!svgRefs.nodes.has(c.agent_id)) {
      const spawned = c.spawned_agents || 0;
      const glowR = 18 + Math.min(spawned * 5, 20);
      const nodeR = 10 + Math.min(spawned * 3, 12);

      const isUnreachable = c.health_status === 'unreachable';
      const nodeColor = isUnreachable ? '#6b7280' : '#34d399';
      const glowColor = isUnreachable ? '#6b7280' : '#34d399';

      const glow = svgEl('circle', {
        cx: pos.x, cy: pos.y, r: glowR,
        fill: glowColor, opacity: isUnreachable ? 0.04 : 0.08, filter: 'url(#glow-sm)',
      });
      glow.style.transition = 'r 0.4s ease, opacity 0.3s ease';
      svgRefs.nodeGroup.appendChild(glow);

      const circle = svgEl('circle', {
        cx: pos.x, cy: pos.y, r: nodeR,
        fill: nodeColor,
      });
      circle.style.transition = 'r 0.15s ease, fill 0.3s ease';
      svgRefs.nodeGroup.appendChild(circle);

      // Spawned agent count badge
      let badge = null;
      if (spawned > 0) {
        badge = svgEl('text', {
          x: pos.x, y: pos.y,
          'text-anchor': 'middle',
          'dominant-baseline': 'central',
          fill: '#fff',
          'font-size': '7',
          'font-weight': 'bold',
          'font-family': 'JetBrains Mono, monospace',
          'pointer-events': 'none',
        });
        badge.textContent = spawned;
        svgRefs.nodeGroup.appendChild(badge);
      }

      const name = agentLabel(c);
      const labelSuffix = isUnreachable ? ' \u2298' : '';
      const label = svgEl('text', {
        x: pos.x, y: pos.y + 26,
        'text-anchor': 'middle',
        fill: isUnreachable ? '#f87171' : 'rgb(var(--c-pale))',
        'font-size': '8',
        'font-family': 'JetBrains Mono, monospace',
      });
      const truncName = name.length > 14 ? name.slice(0, 12) + '..' : name;
      label.textContent = truncName + labelSuffix;
      svgRefs.labelGroup.appendChild(label);

      const hit = svgEl('circle', {
        cx: pos.x, cy: pos.y, r: 28,
        fill: 'transparent', class: 'cursor-pointer',
      });
      hit.addEventListener('mouseenter', (e) => {
        const baseR = parseFloat(circle.getAttribute('r')) || 10;
        circle.setAttribute('r', baseR + 2);
        showMeshTooltip(c, e);
      });
      hit.addEventListener('mousemove', (e) => moveMeshTooltip(e));
      hit.addEventListener('mouseleave', () => {
        const spawned = c.spawned_agents || 0;
        circle.setAttribute('r', 10 + Math.min(spawned * 3, 12));
        hideMeshTooltip();
      });
      hit.addEventListener('click', () => {
        targetValue.value = c.agent_id;
        targetLabel.textContent = agentLabel(c);
        const iconEl = document.getElementById('route-icon');
        iconEl.innerHTML = '<circle cx="5" cy="5" r="3" fill="currentColor"/>';
        iconEl.setAttribute('class', 'text-mesh-blue shrink-0');
        composeInput.focus();
      });
      svgRefs.hitGroup.appendChild(hit);

      svgRefs.nodes.set(c.agent_id, { circle, label, hit, glow, badge });
    } else {
      // Update existing node — label + size + badge + health based on state
      const refs = svgRefs.nodes.get(c.agent_id);
      const isUnreachable = c.health_status === 'unreachable';
      const name = agentLabel(c);
      const labelSuffix = isUnreachable ? ' \u2298' : '';
      const labelText = (name.length > 14 ? name.slice(0, 12) + '..' : name) + labelSuffix;
      if (refs.label.textContent !== labelText) {
        refs.label.textContent = labelText;
      }
      refs.label.setAttribute('fill', isUnreachable ? '#f87171' : 'rgb(var(--c-pale))');
      refs.circle.setAttribute('fill', isUnreachable ? '#6b7280' : '#34d399');
      if (refs.glow) {
        refs.glow.setAttribute('fill', isUnreachable ? '#6b7280' : '#34d399');
        refs.glow.setAttribute('opacity', isUnreachable ? '0.04' : '0.08');
      }
      const spawned = c.spawned_agents || 0;
      refs.circle.setAttribute('r', 10 + Math.min(spawned * 3, 12));
      if (refs.glow) {
        refs.glow.setAttribute('r', 18 + Math.min(spawned * 5, 20));
      }
      // Update badge
      if (spawned > 0) {
        if (!refs.badge) {
          const pos = nodePositions.get(c.agent_id) || { x: 0, y: 0 };
          refs.badge = svgEl('text', {
            x: pos.x, y: pos.y,
            'text-anchor': 'middle',
            'dominant-baseline': 'central',
            fill: '#fff',
            'font-size': '7',
            'font-weight': 'bold',
            'font-family': 'JetBrains Mono, monospace',
            'pointer-events': 'none',
          });
          svgRefs.nodeGroup.appendChild(refs.badge);
        }
        refs.badge.textContent = spawned;
      } else if (refs.badge) {
        refs.badge.remove();
        refs.badge = null;
      }
    }
  });
}

function rebuildSVG() {
  // Full rebuild — used on theme change
  svgRefs.lines.clear();
  svgRefs.nodes.clear();
  svgRefs.lineHits.clear();
  // Clean up orbital planets
  for (const [agentId, planets] of orbitingPlanets) {
    const anim = orbitAnimFrames.get(agentId);
    if (anim) cancelAnimationFrame(anim.raf);
  }
  orbitingPlanets.clear();
  orbitAnimFrames.clear();
  lineWaveTimers.clear();
  initSVG();
  updateConstellationNodes(currentConns);
}

// Mesh tooltip
function showMeshTooltip(c, e) {
  const tip = document.getElementById('mesh-tooltip');
  if (!tip) return;
  document.getElementById('mesh-tooltip-name').textContent = agentLabel(c);
  document.getElementById('mesh-tooltip-bio').textContent = c.bio ? c.bio.slice(0, 80) : 'No bio';
  tip.classList.remove('hidden');
  moveMeshTooltip(e);
}

function moveMeshTooltip(e) {
  const tip = document.getElementById('mesh-tooltip');
  if (!tip) return;
  const cr = constellationArea.getBoundingClientRect();
  let x = e.clientX - cr.left + 12;
  let y = e.clientY - cr.top - 12;
  if (x + 200 > cr.width) x = x - 224;
  if (y < 0) y = y + 30;
  tip.style.left = x + 'px';
  tip.style.top = y + 'px';
}

function hideMeshTooltip() {
  const tip = document.getElementById('mesh-tooltip');
  if (tip) {
    tip.classList.add('hidden');
    const bioEl = document.getElementById('mesh-tooltip-bio');
    if (bioEl) bioEl.style.whiteSpace = '';
  }
}

// =========================================================================
// Particle & Ring Animations
// =========================================================================
function animateParticle(fromX, fromY, toX, toY, color, duration) {
  duration = duration || 600;
  const particle = svgEl('circle', { cx: fromX, cy: fromY, r: 3.5, fill: color, opacity: 0.9 });
  svgRefs.particleGroup.appendChild(particle);

  const start = performance.now();
  function step(now) {
    const t = Math.min((now - start) / duration, 1);
    const ease = t < 0.5 ? 2*t*t : -1+(4-2*t)*t; // ease in-out quad
    particle.setAttribute('cx', fromX + (toX - fromX) * ease);
    particle.setAttribute('cy', fromY + (toY - fromY) * ease);
    particle.setAttribute('opacity', String(0.9 - t * 0.5));
    particle.setAttribute('r', String(3.5 - t * 1.5));
    if (t < 1) requestAnimationFrame(step);
    else particle.remove();
  }
  requestAnimationFrame(step);
}

function animateSendParticle(agentId) {
  const pos = nodePositions.get(agentId);
  if (!pos) return;
  animateParticle(centerPos.x, centerPos.y, pos.x, pos.y, '#dd8040', 600);
}

function animateReceiveParticle(agentId) {
  const pos = nodePositions.get(agentId);
  if (!pos) return;
  animateParticle(pos.x, pos.y, centerPos.x, centerPos.y, '#60a5fa', 600);
}

function animateResponseParticle(agentId) {
  const pos = nodePositions.get(agentId);
  if (!pos) return;
  animateParticle(pos.x, pos.y, centerPos.x, centerPos.y, '#34d399', 700);
}

function animateForwardParticle(fromAgentId, toAgentId) {
  const from = nodePositions.get(fromAgentId);
  const to = nodePositions.get(toAgentId);
  if (!from || !to) return;
  animateParticle(from.x, from.y, to.x, to.y, '#a78bfa', 500);
}

function showRingExpand(agentId, color) {
  const pos = nodePositions.get(agentId);
  if (!pos) return;
  const ring = svgEl('circle', {
    cx: pos.x, cy: pos.y, r: 8,
    fill: 'none', stroke: color, 'stroke-width': 2, opacity: 0.8,
  });
  svgRefs.particleGroup.appendChild(ring);

  const start = performance.now();
  const duration = 600;
  function step(now) {
    const t = Math.min((now - start) / duration, 1);
    ring.setAttribute('r', String(8 + t * 25));
    ring.setAttribute('opacity', String(0.8 * (1 - t)));
    ring.setAttribute('stroke-width', String(2 - t * 1.5));
    if (t < 1) requestAnimationFrame(step);
    else ring.remove();
  }
  requestAnimationFrame(step);
}

// =========================================================================
// Orbital Planet System — replaces responding throb
// =========================================================================
function addOrbitingPlanet(agentId, messageId, fromSelf) {
  if (!orbitingPlanets.has(agentId)) orbitingPlanets.set(agentId, new Map());
  const planets = orbitingPlanets.get(agentId);
  if (planets.has(messageId)) return; // already orbiting

  const pos = nodePositions.get(agentId);
  const refs = svgRefs.nodes.get(agentId);
  if (!pos || !refs) return;

  // Color by agent: sent messages use the target agent's color
  const color = fromSelf ? '#dd8040' : agentColor(agentId);
  const planetIndex = planets.size;
  const nodeR = parseFloat(refs.circle.getAttribute('r')) || 10;

  // Each planet gets a unique elliptical orbit + speed
  const baseR = nodeR + 10 + (planetIndex * 6);
  const rx = baseR + (Math.random() * 8 - 4);           // semi-major axis
  const ry = baseR * (0.5 + Math.random() * 0.4);       // semi-minor axis (ellipse)
  const tilt = Math.random() * Math.PI;                  // orbit tilt angle
  const period = 1800 + Math.random() * 1400;            // 1.8s–3.2s per revolution
  const startAngle = Math.random() * Math.PI * 2;
  const clockwise = Math.random() > 0.3 ? 1 : -1;       // mostly clockwise, some counter

  function orbitPos(angle) {
    // Read live position in case node moved
    const p = nodePositions.get(agentId) || pos;
    const lx = rx * Math.cos(angle);
    const ly = ry * Math.sin(angle);
    return {
      x: p.x + lx * Math.cos(tilt) - ly * Math.sin(tilt),
      y: p.y + lx * Math.sin(tilt) + ly * Math.cos(tilt),
    };
  }

  const startPos = orbitPos(startAngle);
  const el = svgEl('circle', {
    cx: startPos.x, cy: startPos.y,
    r: 3.5, fill: color, opacity: 0.9,
  });
  el.style.transition = 'none';
  svgRefs.particleGroup.appendChild(el);

  // Trail circles
  const trail = [];
  const trailSizes = [2.5, 2, 1.5];
  const trailOpacities = [0.3, 0.2, 0.1];
  const trailOffsets = [-0.25, -0.5, -0.75];
  for (let i = 0; i < 3; i++) {
    const tp = orbitPos(startAngle + trailOffsets[i] * clockwise);
    const t = svgEl('circle', {
      cx: tp.x, cy: tp.y,
      r: trailSizes[i], fill: color, opacity: trailOpacities[i],
    });
    svgRefs.particleGroup.appendChild(t);
    trail.push(t);
  }

  // Materialize animation: scale 0→1
  el.setAttribute('r', '0');
  const matStart = performance.now();
  function materialize(now) {
    const t = Math.min((now - matStart) / 200, 1);
    el.setAttribute('r', String(3.5 * t));
    if (t < 1) requestAnimationFrame(materialize);
  }
  requestAnimationFrame(materialize);

  planets.set(messageId, {
    el, trail, angle: startAngle,
    speed: clockwise * (2 * Math.PI) / period,
    rx, ry, tilt, color, orbitPos,
  });

  // Tint node amber on first planet
  if (planets.size === 1) {
    refs.circle.setAttribute('fill', '#fbbf24');
  }

  // Start animation loop if not running
  if (!orbitAnimFrames.has(agentId)) {
    const lastTime = performance.now();
    function loop(now) {
      updateOrbits(agentId, now);
      orbitAnimFrames.set(agentId, { raf: requestAnimationFrame(loop), lastTime: now });
    }
    orbitAnimFrames.set(agentId, { raf: requestAnimationFrame(loop), lastTime });
  }
}

function removeOrbitingPlanet(agentId, messageId) {
  const planets = orbitingPlanets.get(agentId);
  if (!planets) return;
  const planet = planets.get(messageId);
  if (!planet) return;

  // Burst animation: expand and fade
  const burstStart = performance.now();
  const origR = 3.5;
  function burst(now) {
    const t = Math.min((now - burstStart) / 300, 1);
    planet.el.setAttribute('r', String(origR + t * 8));
    planet.el.setAttribute('opacity', String(0.9 * (1 - t)));
    if (t < 1) {
      requestAnimationFrame(burst);
    } else {
      planet.el.remove();
      planet.trail.forEach(t => t.remove());
    }
  }
  requestAnimationFrame(burst);

  planets.delete(messageId);

  // If no more planets, stop animation and reset node color
  if (planets.size === 0) {
    orbitingPlanets.delete(agentId);
    const anim = orbitAnimFrames.get(agentId);
    if (anim) { cancelAnimationFrame(anim.raf); orbitAnimFrames.delete(agentId); }
    const refs = svgRefs.nodes.get(agentId);
    if (refs) refs.circle.setAttribute('fill', '#34d399');
  }
}

function updateOrbits(agentId, now) {
  const planets = orbitingPlanets.get(agentId);
  if (!planets || planets.size === 0) return;

  const anim = orbitAnimFrames.get(agentId);
  const dt = (now - (anim ? anim.lastTime : now)) / 1000;

  for (const [, p] of planets) {
    p.angle += p.speed * dt;
    if (p.angle > Math.PI * 2) p.angle -= Math.PI * 2;
    if (p.angle < 0) p.angle += Math.PI * 2;

    const pp = p.orbitPos(p.angle);
    p.el.setAttribute('cx', String(pp.x));
    p.el.setAttribute('cy', String(pp.y));

    // Trail follows at angle offsets
    const dir = p.speed > 0 ? 1 : -1;
    const trailOffsets = [-0.25 * dir, -0.5 * dir, -0.75 * dir];
    for (let i = 0; i < p.trail.length; i++) {
      const tp = p.orbitPos(p.angle + trailOffsets[i]);
      p.trail[i].setAttribute('cx', String(tp.x));
      p.trail[i].setAttribute('cy', String(tp.y));
    }
  }
}

function syncOrbitPositions() {
  // Called from layoutPeers when nodes move — orbits auto-sync on next frame via nodePositions
  // Nothing extra needed since updateOrbits reads nodePositions each frame
}

function showNodeFlash(agentId, color) {
  const refs = svgRefs.nodes.get(agentId);
  if (!refs) return;
  const spawned = (currentConns.find(c => c.agent_id === agentId) || {}).spawned_agents || 0;
  refs.circle.setAttribute('fill', color);
  refs.circle.setAttribute('r', String(14 + Math.min(spawned * 3, 12)));
  setTimeout(() => {
    refs.circle.setAttribute('fill', '#34d399');
    refs.circle.setAttribute('r', String(10 + Math.min(spawned * 3, 12)));
  }, 400);
}

function showScatterParticles(agentId) {
  const pos = nodePositions.get(agentId);
  if (!pos) return;
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI * 2 * i) / 6;
    const dx = Math.cos(angle) * 20;
    const dy = Math.sin(angle) * 20;
    const p = svgEl('circle', { cx: pos.x, cy: pos.y, r: 2, fill: '#f87171', opacity: 0.8 });
    svgRefs.particleGroup.appendChild(p);
    const start = performance.now();
    (function(particle, ddx, ddy) {
      function step(now) {
        const t = Math.min((now - start) / 500, 1);
        particle.setAttribute('cx', String(pos.x + ddx * t));
        particle.setAttribute('cy', String(pos.y + ddy * t));
        particle.setAttribute('opacity', String(0.8 * (1 - t)));
        particle.setAttribute('r', String(2 * (1 - t)));
        if (t < 1) requestAnimationFrame(step);
        else particle.remove();
      }
      requestAnimationFrame(step);
    })(p, dx, dy);
  }
}

// =========================================================================
// Line Wave — directional dash animation on a connection line
// =========================================================================
function startLineWave(agentId, color, duration, direction) {
  // direction: 'out' = center→peer, 'in' = peer→center
  duration = duration || 2000;
  color = color || '#dd8040';
  const lineRefs = svgRefs.lines.get(agentId);
  if (!lineRefs) return;

  // Stop any existing wave on this line
  stopLineWave(agentId);

  const base = lineRefs.base;
  const glow = lineRefs.glow;

  // Compute dash length from line geometry
  const x1 = parseFloat(base.getAttribute('x1'));
  const y1 = parseFloat(base.getAttribute('y1'));
  const x2 = parseFloat(base.getAttribute('x2'));
  const y2 = parseFloat(base.getAttribute('y2'));
  const lineLen = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
  const dashLen = 12;
  const gapLen = lineLen; // one dash + big gap = "traveling" look

  glow.setAttribute('stroke', color);
  glow.setAttribute('stroke-dasharray', `${dashLen},${gapLen}`);
  glow.setAttribute('opacity', '0.7');

  const startTime = performance.now();
  const sign = direction === 'in' ? -1 : 1;

  function step(now) {
    const elapsed = now - startTime;
    const t = elapsed / duration;
    if (t >= 1) {
      glow.setAttribute('opacity', '0');
      lineWaveTimers.delete(agentId);
      return;
    }
    // Move dash along the line
    const offset = sign * t * (lineLen + dashLen);
    glow.setAttribute('stroke-dashoffset', String(-offset));
    // Fade out in last 30%
    const alpha = t > 0.7 ? 0.7 * (1 - (t - 0.7) / 0.3) : 0.7;
    glow.setAttribute('opacity', String(alpha));
    lineWaveTimers.set(agentId, { raf: requestAnimationFrame(step), startTime });
  }
  lineWaveTimers.set(agentId, { raf: requestAnimationFrame(step), startTime });
}

function stopLineWave(agentId) {
  const timer = lineWaveTimers.get(agentId);
  if (timer) {
    cancelAnimationFrame(timer.raf);
    lineWaveTimers.delete(agentId);
  }
  const lineRefs = svgRefs.lines.get(agentId);
  if (lineRefs) lineRefs.glow.setAttribute('opacity', '0');
}

// =========================================================================
// Line Pulse — brief color flash on the connection line (for webhook updates)
// =========================================================================
function pulseLineColor(agentId, color, duration) {
  duration = duration || 800;
  const lineRefs = svgRefs.lines.get(agentId);
  if (!lineRefs) return;

  const base = lineRefs.base;
  const origStroke = 'rgb(var(--c-edge))';

  base.setAttribute('stroke', color);
  base.setAttribute('stroke-width', '2.5');

  const start = performance.now();
  function step(now) {
    const t = Math.min((now - start) / duration, 1);
    const w = 2.5 - t * 1; // 2.5 → 1.5
    base.setAttribute('stroke-width', String(w));
    if (t >= 1) {
      base.setAttribute('stroke', origStroke);
      base.setAttribute('stroke-width', '1.5');
      return;
    }
    // Lerp opacity of color flash
    if (t > 0.5) {
      base.setAttribute('stroke', origStroke);
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// =========================================================================
// Line Tooltip — hover over a line to see recent messages
// =========================================================================
function trackLineMessage(agentId, content, status, direction) {
  if (!lineMessageHistory.has(agentId)) lineMessageHistory.set(agentId, []);
  const history = lineMessageHistory.get(agentId);
  history.unshift({ content, status, direction, time: new Date().toISOString() });
  if (history.length > 5) history.length = 5; // keep last 5
}

function showLineTooltip(agentId, e) {
  const tip = document.getElementById('mesh-tooltip');
  if (!tip) return;
  const nameEl = document.getElementById('mesh-tooltip-name');
  const bioEl = document.getElementById('mesh-tooltip-bio');

  const history = lineMessageHistory.get(agentId) || [];
  const conn = currentConns.find(c => c.agent_id === agentId);
  const name = conn ? agentLabel(conn) : shortId(agentId);

  if (history.length === 0) {
    nameEl.textContent = name;
    bioEl.textContent = 'No messages yet';
  } else {
    nameEl.textContent = name;
    const lines = history.slice(0, 3).map(m => {
      const arrow = m.direction === 'out' ? '\u2192' : '\u2190';
      const preview = m.content.length > 40 ? m.content.slice(0, 38) + '..' : m.content;
      return `${arrow} ${preview} (${timeAgo(m.time)})`;
    });
    bioEl.textContent = lines.join('\n');
    bioEl.style.whiteSpace = 'pre-line';
  }

  tip.classList.remove('hidden');
  moveMeshTooltip(e);
}


// =========================================================================
// Message Flow Visualization — process outbox updates
// =========================================================================
function processOutboxVisuals(outbox) {
  for (const msg of outbox) {
    const targets = msg.routed_to || [];
    const isActive = msg.status === 'active';

    // Simple rule: active message = orbit. Not active = no orbit.
    if (isActive) {
      for (const id of targets) {
        addOrbitingPlanet(id, msg.message_id, msg.from_self);
      }
    } else {
      for (const id of targets) {
        removeOrbitingPlanet(id, msg.message_id);
      }
    }
  }

}

// =========================================================================
// Compose — send message
// =========================================================================
composeForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  const content = composeInput.value.trim();
  if (!content) return;
  const target = targetValue.value;
  const isBroadcast = target === 'broadcast';

  sendBtn.disabled = true;
  composeInput.value = '';
  composeInput.style.height = 'auto';

  try {
    const result = await ajaxPost('/send', { content, target });
    if (!result.success) {
      showToast(result.error || 'Send failed', 'error');
    } else {
      if (isBroadcast && result.broadcast) {
        addActivity('&#x21D1;', 'text-mesh-yellow', `Broadcast to ${result.sent_count} agent${result.sent_count !== 1 ? 's' : ''}`);
        showToast(`Broadcast to ${result.sent_count} agent${result.sent_count !== 1 ? 's' : ''}`, 'success');
        for (const [id] of nodePositions) {
          setTimeout(() => {
            animateSendParticle(id);
            startLineWave(id, '#fbbf24', 1200, 'out');
          }, Math.random() * 200);
        }
      } else {
        addActivity('&uarr;', 'text-solar-400', 'Sent message');
        if (target !== 'auto' && nodePositions.has(target)) {
          animateSendParticle(target);
          startLineWave(target, '#dd8040', 1500, 'out');
        } else if (result.routed_to && result.routed_to.length > 0) {
          result.routed_to.forEach((id, i) => setTimeout(() => {
            animateSendParticle(id);
            startLineWave(id, '#dd8040', 1500, 'out');
          }, i * 100));
        }
      }
      // Force poll + scroll timeline to bottom so user sees their message
      pollServer();
      if (timelineScroll) setTimeout(() => { timelineScroll.scrollTop = timelineScroll.scrollHeight; }, 300);
    }
  } catch (err) {
    showToast('Failed to send message', 'error');
  } finally {
    sendBtn.disabled = false;
    composeInput.focus();
  }
});

composeInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    composeForm.dispatchEvent(new Event('submit'));
  }
});

// =========================================================================
// Connect form
// =========================================================================
connectForm.addEventListener('submit', async (e) => {
  e.preventDefault();
  const urlInput = connectForm.querySelector('input[name="url"]');
  const url = urlInput.value.trim();
  if (!url) return;

  const btn = connectForm.querySelector('button');
  btn.disabled = true;
  try {
    const result = await ajaxPost('/connect', { url });
    if (result.success) {
      showToast(result.status === 'connected' ? 'Connected' : 'Request sent', 'success');
      addActivity('+', 'text-mesh-green', `Connected to ${url.split(':').pop()}`);
      urlInput.value = '';
    } else {
      showToast(result.error || 'Connection failed', 'error');
    }
  } catch (err) {
    showToast('Connection failed', 'error');
  } finally {
    btn.disabled = false;
  }
  pollServer();
});

// =========================================================================
// Render pending requests (diff-aware)
// =========================================================================
function renderPending(requests) {
  if (requests.length === 0) {
    pendingSection.classList.add('hidden');
    for (const [id, entry] of renderedPending) { entry.el.remove(); }
    renderedPending.clear();
    return;
  }
  pendingSection.classList.remove('hidden');

  const currentIds = new Set(requests.map(r => r.request_id));
  for (const [id, entry] of renderedPending) {
    if (!currentIds.has(id)) { entry.el.remove(); renderedPending.delete(id); }
  }

  requests.forEach(r => {
    if (renderedPending.has(r.request_id)) return;

    const el = document.createElement('div');
    el.className = 'bg-slab border border-edge rounded p-2 flex items-center justify-between gap-2 slide-in-left';
    el.innerHTML = `
      <div class="min-w-0">
        <div class="text-[11px] text-bright font-medium truncate">${esc(agentLabel(r))}</div>
        ${r.from_bio ? `<div class="text-[10px] text-muted truncate mt-0.5">${esc(r.from_bio.slice(0, 40))}</div>` : ''}
      </div>
      <div class="flex gap-1 shrink-0">
        <button class="accept-btn bg-mesh-green/15 hover:bg-mesh-green/25 text-mesh-green text-[10px] px-2 py-0.5 rounded transition-colors font-medium">Accept</button>
        <button class="reject-btn bg-mesh-red/15 hover:bg-mesh-red/25 text-mesh-red text-[10px] px-2 py-0.5 rounded transition-colors">Deny</button>
      </div>`;

    el.querySelector('.accept-btn').addEventListener('click', async () => {
      try {
        const result = await ajaxPost(`/accept/${encodeURIComponent(r.request_id)}`, {});
        if (result.success) {
          showToast(`Connected to ${agentLabel(r)}`, 'success');
          addActivity('+', 'text-mesh-green', `Accepted ${agentLabel(r)}`);
        }
      } catch (err) { showToast('Accept failed', 'error'); }
      pollServer();
    });

    el.querySelector('.reject-btn').addEventListener('click', async () => {
      try {
        await ajaxPost(`/reject/${encodeURIComponent(r.request_id)}`, {});
        showToast('Request denied', 'info');
      } catch (err) { showToast('Reject failed', 'error'); }
      pollServer();
    });

    pendingListEl.appendChild(el);
    renderedPending.set(r.request_id, { el });
  });
}

// =========================================================================
// Render discovered agents (diff-aware)
// =========================================================================
function renderDiscovered(agents) {
  const currentIds = new Set(agents.map(a => a.agent_id));
  for (const [id, entry] of renderedDiscovered) {
    if (!currentIds.has(id)) { entry.el.remove(); renderedDiscovered.delete(id); }
  }

  if (agents.length === 0 && renderedDiscovered.size === 0) {
    if (!discoveredList.querySelector('.text-muted')) {
      discoveredList.innerHTML = '<p class="text-[10px] text-muted italic">No agents found</p>';
    }
    return;
  }

  const placeholder = discoveredList.querySelector('p.text-muted');
  if (placeholder && agents.length > 0) placeholder.remove();

  agents.forEach(a => {
    const hash = `${a.display_name}|${a.bio}|${a.port}|${a.status}`;
    const existing = renderedDiscovered.get(a.agent_id);
    if (existing && existing.hash === hash) return;
    if (existing) { existing.el.remove(); renderedDiscovered.delete(a.agent_id); }

    const el = document.createElement('div');
    el.className = 'bg-slab border border-edge rounded p-2 flex items-center justify-between gap-2';
    el.innerHTML = `
      <div class="min-w-0">
        <div class="flex items-center gap-1">
          <span class="text-[11px] text-bright font-medium truncate">${esc(agentLabel(a))}</span>
          <span class="text-[10px] text-faint">:${a.port}</span>
        </div>
        ${a.bio ? `<div class="text-[10px] text-muted truncate mt-0.5">${esc(a.bio.slice(0, 35))}</div>` : ''}
      </div>
      <button type="button"
        class="connect-btn shrink-0 bg-mesh-blue/15 hover:bg-mesh-blue/25 text-mesh-blue text-[10px] px-2 py-0.5 rounded transition-colors font-medium">
        Connect
      </button>`;

    el.querySelector('.connect-btn').addEventListener('click', async (e) => {
      const btn = e.currentTarget;
      btn.disabled = true; btn.textContent = '...';
      try {
        const result = await ajaxPost('/connect', { url: a.url });
        if (result.success) {
          showToast(result.status === 'connected' ? `Connected to ${agentLabel(a)}` : 'Request sent', 'success');
          addActivity('+', 'text-mesh-green', `Connected to ${agentLabel(a)}`);
        } else { showToast(result.error || 'Failed', 'error'); }
      } catch (err) { showToast('Connection failed', 'error'); }
      btn.disabled = false; btn.textContent = 'Connect';
      pollServer();
    });

    discoveredList.appendChild(el);
    renderedDiscovered.set(a.agent_id, { el, hash });
  });
}

// =========================================================================
// Render connections — sidebar list + constellation
// =========================================================================
function createCompactConnNode(c) {
  const el = document.createElement('div');
  el.className = 'flex items-center justify-between text-[10px] py-0.5 group';
  const isUnreachable = c.health_status === 'unreachable';
  const dotColor = isUnreachable ? 'bg-mesh-red' : 'bg-mesh-green';
  const nameClass = isUnreachable ? 'text-muted truncate' : 'text-pale truncate';
  const suffix = isUnreachable ? ' <span class="text-[8px] text-mesh-red">\u2298</span>' : '';
  el.innerHTML = `
    <div class="flex items-center gap-1.5 min-w-0">
      <div class="w-1.5 h-1.5 rounded-full ${dotColor} shrink-0"></div>
      <span class="${nameClass}">${esc(agentLabel(c))}${suffix}</span>
      <span class="text-[9px] text-faint">${c.direction === 'inbound' ? '&#8592;' : '&#8594;'}</span>
    </div>
    <button type="button" class="dc-btn text-faint hover:text-mesh-red transition-colors ml-1 shrink-0 opacity-0 group-hover:opacity-100">&times;</button>`;

  el.querySelector('.dc-btn').addEventListener('click', async () => {
    try {
      await ajaxPost(`/disconnect/${encodeURIComponent(c.agent_id)}`, {});
      showToast(`Disconnected from ${agentLabel(c)}`, 'info');
      addActivity('&minus;', 'text-mesh-red', `Disconnected from ${agentLabel(c)}`);
    } catch (err) { showToast('Disconnect failed', 'error'); }
    pollServer();
  });
  return el;
}

function createMobileConnNode(c) {
  const el = document.createElement('div');
  el.className = 'bg-slab border border-edge rounded p-2 group';
  const isUnreachable = c.health_status === 'unreachable';
  const dotColor = isUnreachable ? 'bg-mesh-red' : 'bg-mesh-green';
  const nameClass = isUnreachable ? 'text-[11px] text-muted font-medium truncate' : 'text-[11px] text-bright font-medium truncate';
  const suffix = isUnreachable ? ' <span class="text-[9px] text-mesh-red">\u2298</span>' : '';
  el.innerHTML = `
    <div class="flex items-center justify-between">
      <div class="flex items-center gap-1.5 min-w-0">
        <div class="w-1.5 h-1.5 rounded-full ${dotColor} shrink-0"></div>
        <span class="${nameClass}">${esc(agentLabel(c))}${suffix}</span>
        <span class="text-[9px] text-faint">${c.direction === 'inbound' ? '&larr;' : '&rarr;'}</span>
      </div>
      <button type="button" class="dc-btn text-faint hover:text-mesh-red text-[11px] opacity-0 group-hover:opacity-100 transition-all">&times;</button>
    </div>
    ${c.bio ? `<div class="text-[10px] text-muted truncate mt-0.5 pl-3">${esc(c.bio.slice(0, 50))}</div>` : ''}
    ${c.last_activity ? `<div class="text-[9px] text-faint mt-0.5 pl-3">${timeAgo(c.last_activity)}</div>` : ''}`;

  el.querySelector('.dc-btn').addEventListener('click', async () => {
    try {
      await ajaxPost(`/disconnect/${encodeURIComponent(c.agent_id)}`, {});
      showToast(`Disconnected from ${agentLabel(c)}`, 'info');
      addActivity('&minus;', 'text-mesh-red', `Disconnected from ${agentLabel(c)}`);
    } catch (err) { showToast('Disconnect failed', 'error'); }
    pollServer();
  });
  return el;
}

function connHash(c) {
  return `${c.display_name}|${c.bio}|${c.direction}|${c.last_activity}|${c.health_status || 'ok'}`;
}

function renderConnections(conns) {
  // Update constellation SVG
  updateConstellationNodes(conns);

  // Sidebar compact list
  const currentIds = new Set(conns.map(c => c.agent_id));
  for (const [id, entry] of renderedConns) {
    if (!currentIds.has(id)) { entry.el.remove(); renderedConns.delete(id); }
  }
  conns.forEach(c => {
    const h = connHash(c);
    const existing = renderedConns.get(c.agent_id);
    if (existing && existing.hash === h) return;
    if (existing) { existing.el.remove(); renderedConns.delete(c.agent_id); }
    const ph = connectionsList.querySelector('p.text-muted');
    if (ph) ph.remove();
    const el = createCompactConnNode(c);
    connectionsList.appendChild(el);
    renderedConns.set(c.agent_id, { el, hash: h });
  });
  if (conns.length === 0 && connectionsList.children.length === 0) {
    connectionsList.innerHTML = '<p class="text-[10px] text-muted italic">No connections</p>';
  }

  // Mobile list
  for (const [id, entry] of renderedConnsMobile) {
    if (!currentIds.has(id)) { entry.el.remove(); renderedConnsMobile.delete(id); }
  }
  conns.forEach(c => {
    const h = connHash(c);
    const existing = renderedConnsMobile.get(c.agent_id);
    if (existing && existing.hash === h) return;
    if (existing) { existing.el.remove(); renderedConnsMobile.delete(c.agent_id); }
    const el = createMobileConnNode(c);
    mobileConnectionsList.appendChild(el);
    renderedConnsMobile.set(c.agent_id, { el, hash: h });
  });

  document.getElementById('sidebar-conn-count').textContent = conns.length;
  updateDropdownOptions(conns);
}

// =========================================================================
// Activity diffing — detect changes between polls
// =========================================================================
function diffActivity(prev, curr) {
  if (!prev) return;

  const prevConnIds = new Set(prev.connections.map(c => c.agent_id));
  curr.connections.forEach(c => {
    if (!prevConnIds.has(c.agent_id)) {
      addActivity('+', 'text-mesh-green', `Connected: ${agentLabel(c)}`);
    }
  });

  const currConnIds = new Set(curr.connections.map(c => c.agent_id));
  prev.connections.forEach(c => {
    if (!currConnIds.has(c.agent_id)) {
      addActivity('&minus;', 'text-mesh-red', `Disconnected: ${agentLabel(c)}`);
    }
  });

  const prevInboxIds = new Set(prev.inbox.map(m => m.message_id));
  curr.inbox.forEach(m => {
    if (!prevInboxIds.has(m.message_id)) {
      addActivity('&darr;', 'text-mesh-blue', `Message from ${agentLabel(m)}`);
      if (m.from_agent_id && nodePositions.has(m.from_agent_id)) {
        animateReceiveParticle(m.from_agent_id);
        startLineWave(m.from_agent_id, '#60a5fa', 1500, 'in');
        pulseLineColor(m.from_agent_id, '#60a5fa', 600);
        trackLineMessage(m.from_agent_id, m.content, 'inbox', 'in');
      }
    }
  });

  const prevPendingIds = new Set(prev.pending_requests.map(p => p.request_id));
  curr.pending_requests.forEach(p => {
    if (!prevPendingIds.has(p.request_id)) {
      addActivity('?', 'text-mesh-purple', `Request from ${agentLabel(p)}`);
    }
  });
}

// =========================================================================
// Timeline sidebar
// =========================================================================
function buildThreads(data) {
  const threads = [];
  const conns = data.connections || [];
  const findConn = (id) => conns.find(cn => cn.agent_id === id);

  // Sent messages become threads with answers from responses
  for (const msg of (data.outbox || [])) {
    const agentIds = new Set(msg.routed_to || []);
    const answers = [];
    for (const r of (msg.responses || [])) {
      const c = findConn(r.agent_id);
      const name = c ? agentLabel(c) : (r.display_name || shortId(r.agent_id));
      answers.push({
        agent: name,
        content: r.response,
        timestamp: r.timestamp,
        agent_id: r.agent_id,
      });
      agentIds.add(r.agent_id);
    }
    threads.push({
      id: msg.message_id,
      type: 'sent',
      question: msg.content,
      asker: 'You',
      timestamp: msg.timestamp || msg.created_at,
      agent_ids: [...agentIds],
      answers,
      updates: msg.updates || [],
    });
  }

  // Received messages become threads you can reply to
  for (const msg of (data.inbox || [])) {
    const c = findConn(msg.from_agent_id);
    threads.push({
      id: 'inbox_' + msg.message_id,
      type: 'received',
      question: msg.content,
      asker: c ? agentLabel(c) : (msg.from_display_name || shortId(msg.from_agent_id)),
      timestamp: msg.timestamp || msg.received_at || msg.created_at,
      agent_ids: [msg.from_agent_id],
      answers: [],
      raw_message_id: msg.message_id,
      from_agent_id: msg.from_agent_id,
    });
  }

  threads.sort((a, b) => {
    const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return ta - tb;
  });
  return threads;
}

function relativeTime(ts) {
  if (!ts) return '';
  const diff = (Date.now() - new Date(ts).getTime()) / 1000;
  if (diff < 60) return 'now';
  if (diff < 3600) return Math.floor(diff / 60) + 'm';
  if (diff < 86400) return Math.floor(diff / 3600) + 'h';
  return Math.floor(diff / 86400) + 'd';
}

function buildWebhookBadges(updates) {
  if (!updates || !updates.length) return '';
  const colors = { received: 'bg-blue-500/20 text-blue-400', responding: 'bg-yellow-500/20 text-yellow-400', forwarded: 'bg-purple-500/20 text-purple-400', expired: 'bg-red-500/20 text-red-400' };
  const seen = new Set();
  let html = '<div class="flex flex-wrap gap-0.5 mt-1">';
  for (const u of updates) {
    if (seen.has(u.type)) continue;
    seen.add(u.type);
    const cls = colors[u.type] || 'bg-edge text-muted';
    html += `<span class="text-[10px] px-1.5 py-0.5 rounded-full ${cls}">${u.type}</span>`;
  }
  html += '</div>';
  return html;
}

function buildThreadHTML(thread) {
  const askerColor = thread.type === 'sent' ? 'text-solar-400' : 'text-mesh-blue';
  let html = `<div class="min-w-0">`;

  // Question header: asker label + timestamp
  html += `<div class="flex items-center gap-1.5">
    <span class="text-[10px] ${askerColor} font-medium">${escapeHtml(thread.asker)}</span>
    <span class="text-[10px] text-faint shrink-0 ml-auto">${relativeTime(thread.timestamp)}</span>
  </div>`;

  // Question content — prominent
  html += `<div class="truncated-content text-[12px] text-pale mt-0.5 leading-relaxed cursor-pointer" onclick="this.classList.toggle('expanded')">${escapeHtml(thread.question)}</div>`;

  // Webhook badges for sent threads
  if (thread.type === 'sent') {
    html += buildWebhookBadges(thread.updates);
  }

  // Answers section
  if (thread.answers.length > 0) {
    html += `<div class="border-l-2 border-mesh-green/20 pl-3 ml-1 mt-1.5 space-y-2">`;
    for (const ans of thread.answers) {
      html += `<div>
        <div class="truncated-content text-[12px] text-pale leading-relaxed cursor-pointer" onclick="this.classList.toggle('expanded')">${escapeHtml(ans.content)}</div>
        <div class="flex items-center gap-1.5 mt-0.5">
          <span class="text-[10px] text-faint">${escapeHtml(ans.agent)}</span>
          <span class="text-[10px] text-faint shrink-0 ml-auto">${relativeTime(ans.timestamp)}</span>
        </div>
      </div>`;
    }
    html += `</div>`;
  }

  // Reply input for received threads
  if (thread.type === 'received' && thread.raw_message_id) {
    html += `<div class="flex gap-1.5 mt-1.5">
      <input type="text" placeholder="Reply..."
        data-message-id="${thread.raw_message_id}"
        class="timeline-reply-input flex-1 bg-slab border border-edge rounded px-2 py-1 text-[12px] text-bright placeholder-muted focus:border-mesh-blue/40 transition-colors min-w-0">
      <button type="button" data-message-id="${thread.raw_message_id}"
        class="timeline-reply-btn bg-mesh-blue/15 hover:bg-mesh-blue/25 text-mesh-blue text-[11px] font-medium px-2.5 py-1 rounded transition-colors disabled:opacity-30 shrink-0">
        Reply
      </button>
    </div>`;
  }

  html += `</div>`;
  return html;
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function createTimelineElement(thread) {
  const el = document.createElement('div');
  const borderCls = thread.type === 'sent' ? 'border-solar-500/15' : 'border-mesh-blue/15';
  el.className = `px-3 py-2 rounded-lg border ${borderCls} bg-slab/20 hover:bg-slab/40 transition-colors timeline-enter`;
  el.dataset.timelineId = thread.id;
  el.dataset.agentIds = JSON.stringify(thread.agent_ids || []);
  el.innerHTML = buildThreadHTML(thread);

  el.addEventListener('mouseenter', () => highlightTimelineItem(thread));
  el.addEventListener('mouseleave', () => clearTimelineHighlight());

  if (thread.type === 'received' && thread.raw_message_id) {
    wireTimelineReply(el, thread);
  }
  return el;
}

function wireTimelineReply(el, thread) {
  const input = el.querySelector('.timeline-reply-input');
  const btn = el.querySelector('.timeline-reply-btn');
  if (!input || !btn) return;

  async function doReply() {
    const text = input.value.trim();
    if (!text) return;
    btn.disabled = true;
    input.disabled = true;
    try {
      const result = await ajaxPost(`/respond/${encodeURIComponent(thread.raw_message_id)}`, { response: text });
      if (result.success) {
        showToast('Reply sent', 'success');
        addActivity('&darr;', 'text-mesh-blue', `Replied to ${thread.asker}`);
        input.value = '';
      } else {
        showToast(result.error || 'Reply failed', 'error');
      }
    } catch (err) {
      showToast('Reply failed', 'error');
    }
    btn.disabled = false;
    input.disabled = false;
  }

  btn.addEventListener('click', doReply);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); doReply(); }
  });
}

const renderedThreadAnswerCount = new Map(); // thread.id -> last known answer count

function renderTimeline(data) {
  if (!timelineScroll) return;
  const threads = buildThreads(data);
  const newIds = new Set(threads.map(t => t.id));

  // Remove stale threads
  for (const [id, el] of renderedTimeline) {
    if (!newIds.has(id)) {
      el.remove();
      renderedTimeline.delete(id);
      renderedThreadAnswerCount.delete(id);
    }
  }

  // Check if user is near bottom (for auto-scroll)
  const nearBottom = timelineScroll.scrollHeight - timelineScroll.scrollTop - timelineScroll.clientHeight < 60;

  // Clean dismissed entries that are no longer in the data (prevent unbounded growth)
  for (const id of dismissedTimeline) {
    if (!newIds.has(id)) dismissedTimeline.delete(id);
  }

  // Add/update threads
  for (const thread of threads) {
    if (dismissedTimeline.has(thread.id)) continue;
    const existing = renderedTimeline.get(thread.id);
    if (existing) {
      // Re-render if answer count changed or content updated
      const prevCount = renderedThreadAnswerCount.get(thread.id) || 0;
      const html = buildThreadHTML(thread);
      if (thread.answers.length !== prevCount || existing.innerHTML !== html) {
        existing.innerHTML = html;
        existing.dataset.agentIds = JSON.stringify(thread.agent_ids || []);
        existing.addEventListener('mouseenter', () => highlightTimelineItem(thread));
        existing.addEventListener('mouseleave', () => clearTimelineHighlight());
        if (thread.type === 'received' && thread.raw_message_id) wireTimelineReply(existing, thread);
        renderedThreadAnswerCount.set(thread.id, thread.answers.length);
      }
    } else {
      const el = createTimelineElement(thread);
      timelineScroll.appendChild(el);
      renderedTimeline.set(thread.id, el);
      renderedThreadAnswerCount.set(thread.id, thread.answers.length);
    }
  }

  // Update count badge (only visible items)
  if (timelineCountEl) timelineCountEl.textContent = renderedTimeline.size;

  // Auto-scroll if near bottom
  if (nearBottom) {
    timelineScroll.scrollTop = timelineScroll.scrollHeight;
  }
}

// Timeline hover → mesh node connector
function highlightTimelineItem(item) {
  clearTimelineHighlight();
  const agentIds = item.agent_ids || [];
  if (!agentIds.length) return;

  highlightedTimelineAgent = agentIds[0];

  // Enlarge target node + glow
  for (const agentId of agentIds) {
    const nodeRef = svgRefs.nodes.get(agentId);
    if (nodeRef) {
      const conn = currentConns.find(c => c.agent_id === agentId);
      const spawned = conn ? (conn.spawned_agents || 0) : 0;
      nodeRef.circle.setAttribute('r', String(12 + Math.min(spawned * 3, 12)));
      if (nodeRef.glow) nodeRef.glow.setAttribute('opacity', '0.35');
    }
    // Glow connection line
    const lineRef = svgRefs.lines.get(agentId);
    if (lineRef && lineRef.glow) {
      lineRef.glow.setAttribute('opacity', '0.5');
    }
  }

  // Draw dotted SVG connector from right panel edge to node
  drawTimelineConnector(agentIds[0]);
}

function clearTimelineHighlight() {
  if (!highlightedTimelineAgent) return;

  // Reset all nodes back
  for (const [agentId, nodeRef] of svgRefs.nodes) {
    const conn = currentConns.find(c => c.agent_id === agentId);
    const spawned = conn ? (conn.spawned_agents || 0) : 0;
    nodeRef.circle.setAttribute('r', String(10 + Math.min(spawned * 3, 12)));
    if (nodeRef.glow) nodeRef.glow.setAttribute('opacity', '0.08');
  }
  for (const [, lineRef] of svgRefs.lines) {
    if (lineRef.glow) lineRef.glow.setAttribute('opacity', '0');
  }

  removeTimelineConnector();
  highlightedTimelineAgent = null;
}

function drawTimelineConnector(agentId) {
  if (!svgRefs.connectorGroup) return;
  const pos = nodePositions.get(agentId);
  if (!pos) return;

  const line = svgEl('line', {
    x1: svgW, y1: svgH / 2,
    x2: pos.x, y2: pos.y,
    stroke: '#dd8040',
    'stroke-width': '1',
    'stroke-dasharray': '4 3',
    opacity: '0.5',
  });
  line.classList.add('connector-line');
  svgRefs.connectorGroup.appendChild(line);
  timelineConnectorLine = line;
}

function removeTimelineConnector() {
  if (timelineConnectorLine) {
    timelineConnectorLine.remove();
    timelineConnectorLine = null;
  }
}

function clearTimeline() {
  if (!timelineScroll) return;
  // Mark all currently rendered threads as dismissed so they don't reappear
  for (const [id] of renderedTimeline) dismissedTimeline.add(id);
  timelineScroll.innerHTML = '';
  renderedTimeline.clear();
  renderedThreadAnswerCount.clear();
  if (timelineCountEl) timelineCountEl.textContent = '0';
}

// =========================================================================
// Right panel drag-to-resize
// =========================================================================
(function initPanelResize() {
  const panel = document.getElementById('right-panel');
  const handle = document.getElementById('right-panel-handle');
  if (!panel || !handle) return;

  let startX, startW;

  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    startX = e.clientX;
    startW = panel.offsetWidth;
    document.body.classList.add('resizing-panel');

    function onMove(e) {
      const delta = startX - e.clientX; // dragging left = wider
      const newW = Math.max(200, Math.min(startW + delta, window.innerWidth * 0.5));
      panel.style.width = newW + 'px';
      // Trigger SVG re-layout since constellation area changed
      if (typeof updateSVGLayout === 'function') updateSVGLayout();
    }
    function onUp() {
      document.body.classList.remove('resizing-panel');
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
})();

// =========================================================================
// Main poll handler
// =========================================================================
function onPollData(data) {
  // Activity diffing
  if (data.self) selfAgentId = data.self.agent_id;
  diffActivity(prevPollData, data);
  prevPollData = JSON.parse(JSON.stringify(data));

  // Cache for wallet send form
  _walletData = data;

  // Render constellation + sidebar
  renderPending(data.pending_requests);
  renderDiscovered(data.discovered || []);
  renderConnections(data.connections);

  // Process outbox message visuals (orbits)
  try { processOutboxVisuals(data.outbox); } catch(e) { console.error('processOutboxVisuals error:', e); }

  // Render timeline sidebar
  renderTimeline(data);

  // --- Active agents: grow center node + track per-peer counts ---
  if (data.self) {
    const agents = data.self.total_active_agents || 0;
    totalActiveAgents = agents;

    // Center node grows with total active agents
    if (svgRefs.centerNode) {
      const r = 14 + Math.min(agents * 3, 12);
      svgRefs.centerNode.setAttribute('r', r);
    }
    if (svgRefs.centerGlow) {
      const gr = 34 + Math.min(agents * 6, 24);
      svgRefs.centerGlow.setAttribute('r', gr);
      svgRefs.centerGlow.setAttribute('opacity', 0.1 + Math.min(agents * 0.04, 0.2));
    }
    // Agent count label below "You"
    if (svgRefs.centerAgentLabel) {
      if (agents > 0) {
        svgRefs.centerAgentLabel.textContent = agents + ' agent' + (agents !== 1 ? 's' : '');
        svgRefs.centerAgentLabel.setAttribute('opacity', '1');
      } else {
        svgRefs.centerAgentLabel.setAttribute('opacity', '0');
      }
    }
  }

  // Per-peer agent count activity logging
  data.connections.forEach(c => {
    const count = c.spawned_agents || 0;
    const prev = prevAgentCounts.get(c.agent_id) || 0;
    if (count > prev) {
      const delta = count - prev;
      addActivity('&#9650;', 'text-cyan-400', `${delta} agent${delta !== 1 ? 's' : ''} spawned on ${agentLabel(c)}`);
    } else if (count < prev) {
      addActivity('&#9660;', 'text-mesh-green', `Agent finished on ${agentLabel(c)}`);
    }
    prevAgentCounts.set(c.agent_id, count);
  });

  // QR code init
  if (data.self && data.self.lan_url && !qrInitialized) {
    initQR(data.self.lan_url);
  }

  // NAT status
  if (data.self && data.self.nat_detected) {
    document.getElementById('nat-status').classList.remove('hidden');
  }
}

// =========================================================================
// Init
// =========================================================================
initSVG();

// ResizeObserver for constellation re-layout
if (typeof ResizeObserver !== 'undefined') {
  new ResizeObserver(() => updateSVGLayout()).observe(constellationArea);
}

// =========================================================================
// Wallet — Balances, Send, Identity
// =========================================================================
let _walletQRPollTimer = null;
let _walletData = null;  // cached poll data for connections

function openWalletModal() {
  document.getElementById('wallet-modal').classList.remove('hidden');
  refreshWalletBalances();
  _populateSendForm();
}

function closeWalletModal() {
  document.getElementById('wallet-modal').classList.add('hidden');
  if (_walletQRPollTimer) { clearInterval(_walletQRPollTimer); _walletQRPollTimer = null; }
}

function walletMainTab(tab) {
  const tabs = ['balances', 'send', 'identity'];
  tabs.forEach(t => {
    const btn = document.getElementById(`wallet-main-tab-${t}`);
    const panel = document.getElementById(`wallet-panel-${t}`);
    if (t === tab) {
      btn.className = 'flex-1 text-[10px] font-semibold py-2.5 transition-colors bg-slab/50 text-bright border-b-2 border-solar-400';
      panel.classList.remove('hidden');
    } else {
      btn.className = 'flex-1 text-[10px] font-semibold py-2.5 transition-colors text-muted hover:text-pale border-b-2 border-transparent';
      panel.classList.add('hidden');
    }
  });
  if (tab === 'balances') refreshWalletBalances();
  if (tab === 'send') _populateSendForm();
}

function copyWalletAddr() {
  const addr = document.getElementById('wallet-sol-addr').textContent;
  if (addr) {
    navigator.clipboard.writeText(addr).then(() => showToast('Address copied', 'success'));
  }
}

async function refreshWalletBalances() {
  const addrEl = document.getElementById('wallet-sol-addr');
  const solBalEl = document.getElementById('wallet-sol-balance');
  const tokenContainer = document.getElementById('wallet-token-balances');
  const noSolana = document.getElementById('wallet-no-solana');
  const balancesList = document.getElementById('wallet-balances-list');

  solBalEl.textContent = '...';
  tokenContainer.innerHTML = '<div class="text-[10px] text-muted text-center py-1">Loading...</div>';

  try {
    const resp = await fetch('/api/wallet-balances');
    const data = await resp.json();

    if (!data.success) {
      addrEl.textContent = '';
      noSolana.classList.remove('hidden');
      balancesList.classList.add('hidden');
      tokenContainer.innerHTML = '';
      return;
    }

    noSolana.classList.add('hidden');
    balancesList.classList.remove('hidden');
    addrEl.textContent = data.wallet_address || '';

    // SOL balance
    if (data.sol && data.sol.success) {
      solBalEl.textContent = parseFloat(data.sol.balance).toFixed(6);
    } else {
      solBalEl.textContent = 'Error';
    }

    // Token balances
    tokenContainer.innerHTML = '';
    if (data.tokens) {
      for (const [name, info] of Object.entries(data.tokens)) {
        const bal = info.success ? (parseFloat(info.balance) > 0 ? parseFloat(info.balance).toLocaleString() : '0') : 'Error';
        const row = document.createElement('div');
        row.className = 'flex items-center justify-between px-3 py-1.5 bg-slab/30 rounded';
        row.innerHTML = `<span class="text-[10px] text-pale">${esc(name)}</span><span class="text-[10px] text-muted font-mono">${esc(bal)}</span>`;
        tokenContainer.appendChild(row);
      }
    }
  } catch (e) {
    solBalEl.textContent = 'Error';
    tokenContainer.innerHTML = `<div class="text-[10px] text-mesh-red text-center py-1">${esc(e.message)}</div>`;
  }
}

function _populateSendForm() {
  const select = document.getElementById('wallet-send-recipient');
  const tokenSelect = document.getElementById('wallet-send-token');
  const resultEl = document.getElementById('wallet-send-result');
  resultEl.classList.add('hidden');

  // Populate recipients from last poll data
  select.innerHTML = '<option value="">Select connected agent...</option>';
  if (_walletData && _walletData.connections) {
    _walletData.connections.forEach(c => {
      if (c.wallets && c.wallets.solana) {
        const opt = document.createElement('option');
        opt.value = c.agent_id;
        opt.textContent = `${c.display_name} (${c.wallets.solana.slice(0, 8)}...)`;
        select.appendChild(opt);
      }
    });
  }

  // Populate token options
  tokenSelect.innerHTML = '<option value="SOL">SOL</option>';
  // Fetch known tokens from the balances response
  fetch('/api/wallet-balances').then(r => r.json()).then(data => {
    if (data.known_tokens) {
      data.known_tokens.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t;
        opt.textContent = t;
        tokenSelect.appendChild(opt);
      });
    }
  }).catch(() => {});
}

async function walletSend() {
  const agentId = document.getElementById('wallet-send-recipient').value;
  const amount = document.getElementById('wallet-send-amount').value;
  const token = document.getElementById('wallet-send-token').value;
  const btn = document.getElementById('wallet-send-btn');
  const resultEl = document.getElementById('wallet-send-result');

  if (!agentId) { showToast('Select a recipient', 'error'); return; }
  if (!amount || parseFloat(amount) <= 0) { showToast('Enter a valid amount', 'error'); return; }

  btn.disabled = true;
  btn.textContent = 'Sending...';
  resultEl.classList.add('hidden');

  try {
    const result = await ajaxPost('/api/wallet-send', { agent_id: agentId, amount: parseFloat(amount), token });
    if (result.success) {
      showToast(`Sent ${amount} ${token}`, 'success');
      resultEl.className = 'text-[10px] font-mono bg-mesh-green/5 border border-mesh-green/20 rounded-lg px-3 py-2 break-all text-mesh-green';
      resultEl.textContent = `TX: ${result.tx_signature}`;
      resultEl.classList.remove('hidden');
      document.getElementById('wallet-send-amount').value = '';
    } else {
      showToast(result.error || 'Send failed', 'error');
      resultEl.className = 'text-[10px] font-mono bg-mesh-red/5 border border-mesh-red/20 rounded-lg px-3 py-2 break-all text-mesh-red';
      resultEl.textContent = result.error || 'Unknown error';
      resultEl.classList.remove('hidden');
    }
  } catch (e) {
    showToast('Send failed', 'error');
  } finally {
    btn.disabled = false;
    btn.textContent = 'Send';
  }
}

function walletTab(tab) {
  const extTab = document.getElementById('wallet-tab-ext');
  const qrTab = document.getElementById('wallet-tab-qr');
  const extPanel = document.getElementById('wallet-ext-panel');
  const qrPanel = document.getElementById('wallet-qr-panel');
  if (tab === 'ext') {
    extTab.classList.add('bg-slab', 'text-bright');
    extTab.classList.remove('text-muted');
    qrTab.classList.remove('bg-slab', 'text-bright');
    qrTab.classList.add('text-muted');
    extPanel.classList.remove('hidden');
    qrPanel.classList.add('hidden');
  } else {
    qrTab.classList.add('bg-slab', 'text-bright');
    qrTab.classList.remove('text-muted');
    extTab.classList.remove('bg-slab', 'text-bright');
    extTab.classList.add('text-muted');
    qrPanel.classList.remove('hidden');
    extPanel.classList.add('hidden');
  }
}

function _getSolanaProvider() {
  // Phantom, Solflare, Backpack all inject into window.solana or window.phantom.solana
  if (window.phantom?.solana?.isPhantom) return window.phantom.solana;
  if (window.solana?.isPhantom) return window.solana;
  if (window.solflare?.isSolflare) return window.solflare;
  if (window.backpack?.solana) return window.backpack.solana;
  if (window.solana) return window.solana;
  return null;
}

function _bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function walletAuth() {
  const provider = _getSolanaProvider();
  if (!provider) {
    showToast('No Solana wallet detected — install Phantom', 'error');
    return;
  }

  const btn = document.getElementById('wallet-connect-btn');
  btn.disabled = true;
  btn.textContent = 'Connecting...';

  try {
    // Connect to wallet (prompts user if not already connected)
    const resp = await provider.connect();
    const publicKey = resp.publicKey || provider.publicKey;

    btn.textContent = 'Signing...';

    const challenge = "DarkMatter Identity Derivation v1";
    const encoded = new TextEncoder().encode(challenge);
    const { signature } = await provider.signMessage(encoded, "utf8");

    const remember = document.getElementById('wallet-remember').checked;
    const sigHex = _bytesToHex(signature);
    const pubHex = _bytesToHex(publicKey.toBytes());

    btn.textContent = 'Deriving identity...';

    const authResp = await fetch('/api/wallet-auth', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ public_key: pubHex, signature: sigHex, challenge, remember }),
    });
    const data = await authResp.json();

    if (data.ok) {
      const statusEl = document.getElementById('wallet-status');
      statusEl.textContent = 'Identity: ' + data.agent_id.slice(0, 12) + '...' + data.agent_id.slice(-6);
      statusEl.classList.remove('hidden');
      showToast('Wallet identity active: ' + data.agent_id.slice(0, 8) + '...', 'success');
      setTimeout(() => location.reload(), 1200);
    } else {
      showToast(data.error || 'Wallet auth failed', 'error');
      btn.disabled = false;
      btn.textContent = 'Connect Wallet';
    }
  } catch (e) {
    if (e.code === 4001 || e.message?.includes('rejected')) {
      showToast('Signature rejected by user', 'info');
    } else {
      showToast('Wallet error: ' + (e.message || e), 'error');
    }
    btn.disabled = false;
    btn.textContent = 'Connect Wallet';
  }
}

async function walletDisconnect() {
  try {
    const resp = await fetch('/api/wallet-disconnect', { method: 'POST' });
    const data = await resp.json();
    if (data.ok) {
      showToast('Reverted to original identity', 'success');
      setTimeout(() => location.reload(), 1000);
    } else {
      showToast('Failed to revert', 'error');
    }
  } catch (e) {
    showToast('Error: ' + e.message, 'error');
  }
}

// --- Mobile QR Session ---
async function startQRSession() {
  const remember = document.getElementById('wallet-qr-remember').checked;
  try {
    const resp = await fetch('/api/wallet-session', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ remember }),
    });
    const data = await resp.json();
    if (!data.ok) { showToast(data.error || 'Failed to create session', 'error'); return; }

    // Show QR code
    document.getElementById('wallet-qr-idle').classList.add('hidden');
    const activeEl = document.getElementById('wallet-qr-active');
    activeEl.classList.remove('hidden');

    const qrContainer = document.getElementById('wallet-qr-code');
    qrContainer.innerHTML = '';
    const style = getComputedStyle(document.documentElement);
    new QRCode(qrContainer, {
      text: data.url,
      width: 160, height: 160,
      colorDark: style.getPropertyValue('--qr-fg').trim() || '#e2e2ea',
      colorLight: style.getPropertyValue('--qr-bg').trim() || '#111113',
      correctLevel: QRCode.CorrectLevel.M,
    });
    document.getElementById('wallet-qr-url').textContent = data.url;

    // Poll for completion
    if (_walletQRPollTimer) clearInterval(_walletQRPollTimer);
    _walletQRPollTimer = setInterval(async () => {
      try {
        const pollResp = await fetch('/api/wallet-session/' + data.session_id);
        const pollData = await pollResp.json();
        if (pollData.status === 'applied') {
          clearInterval(_walletQRPollTimer);
          _walletQRPollTimer = null;
          activeEl.classList.add('hidden');
          document.getElementById('wallet-qr-done').classList.remove('hidden');
          const statusEl = document.getElementById('wallet-status');
          statusEl.textContent = 'Identity: ' + pollData.agent_id.slice(0, 12) + '...' + pollData.agent_id.slice(-6);
          statusEl.classList.remove('hidden');
          showToast('Wallet identity active: ' + pollData.agent_id.slice(0, 8) + '...', 'success');
          setTimeout(() => location.reload(), 1200);
        } else if (pollData.status === 'failed') {
          clearInterval(_walletQRPollTimer);
          _walletQRPollTimer = null;
          showToast(pollData.error || 'Signing failed', 'error');
          resetQRPanel();
        }
      } catch (e) { /* keep polling */ }
    }, 2000);

  } catch (e) {
    showToast('Error: ' + e.message, 'error');
  }
}

function resetQRPanel() {
  document.getElementById('wallet-qr-idle').classList.remove('hidden');
  document.getElementById('wallet-qr-active').classList.add('hidden');
  document.getElementById('wallet-qr-done').classList.add('hidden');
}

// Check if wallet identity is active on load and update modal state
fetch('/api/info').then(r => r.json()).then(data => {
  const walletBtn = document.getElementById('wallet-btn');
  if (data.wallet_identity) {
    if (walletBtn) {
      walletBtn.classList.remove('text-pale');
      walletBtn.classList.add('text-solar-400');
      walletBtn.title = 'Wallet identity active';
    }
    document.getElementById('wallet-disconnect-btn').classList.remove('hidden');
    const statusEl = document.getElementById('wallet-status');
    statusEl.textContent = 'Active: ' + data.agent_id.slice(0, 12) + '...' + data.agent_id.slice(-6);
    statusEl.classList.remove('hidden');
  }
  // Show truncated wallet address on the wallet button tooltip
  if (data.wallets && data.wallets.solana) {
    const addr = data.wallets.solana;
    if (walletBtn) walletBtn.title = `Wallet: ${addr.slice(0, 6)}...${addr.slice(-4)}`;
  }
}).catch(() => {});
</script>

{% endblock %}
